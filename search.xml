<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>四大组件之ContentProvider</title>
      <link href="/2020/03/21/si-da-zu-jian-zhi-contentprovider/"/>
      <url>/2020/03/21/si-da-zu-jian-zhi-contentprovider/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文目录结构：<br>一、内容提供器简介<br>二、数据存储方案<br>三、运行时权限<br>四、访问其他程序中的数据<br>五、创建自己的内容提供器</p></blockquote><h3 id="一、内容提供器简介"><a href="#一、内容提供器简介" class="headerlink" title="一、内容提供器简介"></a>一、内容提供器简介</h3><ul><li>作为四大组件之一，Content Provider主要用于存储数据和在不同的应用程序之间共享数据。和文件存储、SharedPreferences存储以及SQLite数据库存储不同，Content Provider可以选择只对哪一部分的数据进行共享，从而保证我们的隐私数据不会存在被泄漏的风险，前者的数据只能在本应用程序中使用。（因为文件存储方式存下的文件是在本应用目录下的，其他应用不知道该应用下这个文件的目录，所以说只能在本应用中使用，当然了你知道的话也是可以使用的）</li><li>内容提供器的用法一般有两种，一种是使用别人为我们提供的内容提供器，本文第四大点会讲到；另一种则是我们创建自己的内容提供器，提供给别人使用。本文第五大点会讲到。</li></ul><h3 id="二、数据存储方案"><a href="#二、数据存储方案" class="headerlink" title="二、数据存储方案"></a>二、数据存储方案</h3><h5 id="2-1-文件存储"><a href="#2-1-文件存储" class="headerlink" title="2.1 文件存储"></a>2.1 文件存储</h5><h6 id="2-1-1-前言"><a href="#2-1-1-前言" class="headerlink" title="2.1.1 前言"></a>2.1.1 前言</h6><p>文件存储是Android中最基本的一种数据存储方式，它不对存储的内容进行任何的格式化处理。因此，它比较适合用于存储一些简单的文本数据或二进制数据。<br>对于存储操作，Context类提供了一个openFileOutput方法。对于读取操作，Context类提供了一个openFileInput方法。两个方法返回的类型分别是FileOutStream和FileInputStream。</p><h6 id="2-1-2-使用方法"><a href="#2-1-2-使用方法" class="headerlink" title="2.1.2 使用方法"></a>2.1.2 使用方法</h6><p>这里结合一个小案例说明：点击“保存”按钮将输入框的内容存储到文件中，点击“读取”按钮则读取文件中的内容</p><p><img src="https://upload-images.jianshu.io/upload_images/15623160-13eb83f8eb0325c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><pre class=" language-bash"><code class="language-bash">//保存数据到文件中     private void saveFile<span class="token punctuation">(</span>String content<span class="token punctuation">)</span> <span class="token punctuation">{</span>        FileOutputStream fos <span class="token operator">=</span> null<span class="token punctuation">;</span>        BufferedWriter bw <span class="token operator">=</span> null<span class="token punctuation">;</span>        try <span class="token punctuation">{</span>            //第一参数是指定文件的名称，这里的名字不可以包含路径，因为所有文件都是存储在/data/data/<span class="token operator">&lt;</span>packagename<span class="token operator">></span>/files/目录下的            //第二个参数是文件的操作模式，主要有两种模式可以选：MODE_PRIVATE（默认）和MODE_APPEND。            //前者表示文件名字相同时会覆盖掉之前的内容，而后者表示会在后面追加内容            fos <span class="token operator">=</span> openFileOutput<span class="token punctuation">(</span><span class="token string">"myFile"</span>, Context.MODE_APPEND<span class="token punctuation">)</span><span class="token punctuation">;</span>            bw <span class="token operator">=</span> new BufferedWriter<span class="token punctuation">(</span>new OutputStreamWriter<span class="token punctuation">(</span>fos<span class="token punctuation">))</span><span class="token punctuation">;</span>            bw.write<span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> catch <span class="token punctuation">(</span>IOException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e.printStackTrace<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> finally <span class="token punctuation">{</span>            try <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>bw <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    bw.close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> catch <span class="token punctuation">(</span>IOException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e.printStackTrace<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>//从文件中读取数据    private String readFile<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        FileInputStream fis <span class="token operator">=</span> null<span class="token punctuation">;</span>        BufferedReader br <span class="token operator">=</span> null<span class="token punctuation">;</span>        StringBuilder builder <span class="token operator">=</span> new StringBuilder<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        try <span class="token punctuation">{</span>            //只接收一个参数，即要打开的文件名            fis <span class="token operator">=</span> openFileInput<span class="token punctuation">(</span><span class="token string">"myFile"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            br <span class="token operator">=</span> new BufferedReader<span class="token punctuation">(</span>new InputStreamReader<span class="token punctuation">(</span>fis<span class="token punctuation">))</span><span class="token punctuation">;</span>            String flag<span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token variable"><span class="token punctuation">((</span>flag <span class="token operator">=</span> br.readLine<span class="token punctuation">(</span><span class="token punctuation">))</span></span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                builder.append<span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> catch <span class="token punctuation">(</span>FileNotFoundException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e.printStackTrace<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> catch <span class="token punctuation">(</span>IOException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e.printStackTrace<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>finally <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>br <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                try <span class="token punctuation">{</span>                    br.close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> catch <span class="token punctuation">(</span>IOException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e.printStackTrace<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> builder.toString<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h5 id="2-2-SharedPreferences存储"><a href="#2-2-SharedPreferences存储" class="headerlink" title="2.2 SharedPreferences存储"></a>2.2 SharedPreferences存储</h5><h6 id="2-2-1-前言"><a href="#2-2-1-前言" class="headerlink" title="2.2.1 前言"></a>2.2.1 前言</h6><p>与文件存储不同，SharedPreferences是用键值对的形式存储数据的。也就是说，当我们保存一条数据的时候，需要给这条数据提供一个对应的键，取的时候也是根据这个键取出来。</p><h6 id="2-2-2-将数据存储到SharedPreferences中"><a href="#2-2-2-将数据存储到SharedPreferences中" class="headerlink" title="2.2.2 将数据存储到SharedPreferences中"></a>2.2.2 将数据存储到SharedPreferences中</h6><p>要想用SharedPreferences存储数据，我们需要先获取SharedPreferences对象。Android主要提供了三种方法来得到该对象。</p><ul><li><strong>Context类中的getSharedPreferences()方法</strong><br>该方法接收两个参数，第一个是指定SharedPreferences文件的名称，该文件都是存放在/data/data/<package name="">/shared_prefs/目录下的。第二个是指定操作模式，目前只有MODE_PRIVATE这一种该模式可选，它也是默认的，与传入0效果是一样的。</package></li><li><strong>Activity类中的getPreferences()方法</strong><br>该方法与上一个方法类似，不过它只接收一个参数，即操作模式。SharedPreferences文件的名称为当前活动的类名。</li><li><strong>PreferenceManager类中的getDefaultSharedPreferences()方法</strong><br>这是一个静态方法，它接收一个Context参数，并自动使用当前应用程序的包名作为前缀来命名。</li></ul><p>拿到SharedPreferences对象之后就可以向SharedPreferences文件存储数据了，步骤如下：<br>① 首先，调用SharedPreferences对象的edit方法来获取一个SharedPreferences.Editor对象。<br>② 然后，向SharedPreferences.Editor对象添加数据，比如添加一个int型数据则可以用putInt()方法，字符串则是putString()方法，以此类推。<br>③ 最后，调用apply或者commit方法将数据提交即可。</p><pre class=" language-bash"><code class="language-bash">SharedPreferences.Editor editor <span class="token operator">=</span> getSharedPreferences<span class="token punctuation">(</span><span class="token string">"myShared"</span>,MODE_PRIVATE<span class="token punctuation">)</span>.edit<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>editor.putString<span class="token punctuation">(</span><span class="token string">"content"</span>,content<span class="token punctuation">)</span><span class="token punctuation">;</span>editor.putInt<span class="token punctuation">(</span><span class="token string">"id"</span>,2016100341<span class="token punctuation">)</span><span class="token punctuation">;</span>editor.putBoolean<span class="token punctuation">(</span><span class="token string">"flag"</span>,true<span class="token punctuation">)</span><span class="token punctuation">;</span>editor.apply<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h6 id="2-2-3-从SharedPreferences中读取数据"><a href="#2-2-3-从SharedPreferences中读取数据" class="headerlink" title="2.2.3 从SharedPreferences中读取数据"></a>2.2.3 从SharedPreferences中读取数据</h6><pre class=" language-bash"><code class="language-bash">SharedPreferences preferences <span class="token operator">=</span> getSharedPreferences<span class="token punctuation">(</span><span class="token string">"myShared"</span>,MODE_PRIVATE<span class="token punctuation">)</span><span class="token punctuation">;</span>//该方法的第一个参数是存数据时写的键值，第二个参数是获取不到这个键对应的值时的默认返回的内容。String result <span class="token operator">=</span> preferences.getString<span class="token punctuation">(</span><span class="token string">"content"</span>,<span class="token string">"error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>int num <span class="token operator">=</span> preferences.getInt<span class="token punctuation">(</span><span class="token string">"id"</span>,0<span class="token punctuation">)</span><span class="token punctuation">;</span>boolean flag <span class="token operator">=</span> preferences.getBoolean<span class="token punctuation">(</span><span class="token string">"flag"</span>,true<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h6 id="2-2-4-注意"><a href="#2-2-4-注意" class="headerlink" title="2.2.4 注意"></a>2.2.4 注意</h6><p>（1）细心的朋友们可能会注意到提交数据的时候不是有两种该方法提交吗？那它们有什么区别呢？<br>① apply无返回值，commit有（boolean）<br>② apply的话是将修改原子提交到内存，而后异步真正提交到硬件，commit是同步提交到硬件，所以相比之下数据量大的时候apply的效率会更高一点。<br>③ apply不会有任何的失败提示。</p><p>（2）当两个Editor在修改preferences时，最后一个调用apply或者commit的才会生效。<br>源码注释：<br>Note that when two editors are modifying preferences at the same time, the last one to call commit wins.<br>Note that when two editors are modifying preferences at the same time, the last one to call apply wins.</p><h5 id="2-3-SQLite数据库存储"><a href="#2-3-SQLite数据库存储" class="headerlink" title="2.3 SQLite数据库存储"></a>2.3 SQLite数据库存储</h5><h6 id="2-3-1-前言"><a href="#2-3-1-前言" class="headerlink" title="2.3.1 前言"></a>2.3.1 前言</h6><ul><li><p>SQLite是一款轻量级的数据库，运算速度非常快，占用资源很少，通常只需要几百KB的内存就够了，因而非常适合在移动设备上使用。SQLite不仅支持标准的SQL语法，还遵循了数据库的ACID事务。</p></li><li><p><strong>整体思路：</strong><br>首先，自定义类继承<strong>SQLiteOpenHelper</strong>，重写<strong>onCreate</strong>和<strong>onUpgrade</strong>方法。<br>然后，实例化该类，调用<strong>getReadableDatabase</strong>或<strong>getWritableDatabase</strong>方法拿到<strong>SQLiteDatabase</strong>对象，这样就创建完数据库了。<br>接着，通过ContentValues的put，clear等方法将数据放进ContentValues中。<br>最后，SQLiteDatabase对象调用insert、update、delete、query方法做增删查改操作（查询的话则用到cursor）。</p></li><li><p>这是一些初始化信息，下面的这个功能都是在这个的基础上实现的。</p><pre class=" language-bash"><code class="language-bash">public class Main5Activity extends AppCompatActivity implements View.OnClickListener <span class="token punctuation">{</span>  private Button btn_create,btn_upgrade,btn_insert,          btn_delete,btn_select,btn_update<span class="token punctuation">;</span>  private MySQLiteHelper helper<span class="token punctuation">;</span>  private SQLiteDatabase db<span class="token punctuation">;</span>  @Override  protected void onCreate<span class="token punctuation">(</span>Bundle savedInstanceState<span class="token punctuation">)</span> <span class="token punctuation">{</span>      super.onCreate<span class="token punctuation">(</span>savedInstanceState<span class="token punctuation">)</span><span class="token punctuation">;</span>      setContentView<span class="token punctuation">(</span>R.layout.activity_main5<span class="token punctuation">)</span><span class="token punctuation">;</span>      helper <span class="token operator">=</span> new MySQLiteHelper<span class="token punctuation">(</span>this,<span class="token string">"BookStore.db"</span>,null,1<span class="token punctuation">)</span><span class="token punctuation">;</span>      btn_create <span class="token operator">=</span> findViewById<span class="token punctuation">(</span>R.id.btn_create<span class="token punctuation">)</span><span class="token punctuation">;</span>//创建数据库      btn_upgrade <span class="token operator">=</span> findViewById<span class="token punctuation">(</span>R.id.btn_upgrade<span class="token punctuation">)</span><span class="token punctuation">;</span>//升级数据库      btn_insert <span class="token operator">=</span> findViewById<span class="token punctuation">(</span>R.id.btn_insert<span class="token punctuation">)</span><span class="token punctuation">;</span>//插入数据      btn_delete <span class="token operator">=</span> findViewById<span class="token punctuation">(</span>R.id.btn_delete<span class="token punctuation">)</span><span class="token punctuation">;</span>//删除数据      btn_select <span class="token operator">=</span> findViewById<span class="token punctuation">(</span>R.id.btn_select<span class="token punctuation">)</span><span class="token punctuation">;</span>//查询数据      btn_update <span class="token operator">=</span> findViewById<span class="token punctuation">(</span>R.id.btn_update<span class="token punctuation">)</span><span class="token punctuation">;</span>//更新数据      btn_create.setOnClickListener<span class="token punctuation">(</span>this<span class="token punctuation">)</span><span class="token punctuation">;</span>      btn_upgrade.setOnClickListener<span class="token punctuation">(</span>this<span class="token punctuation">)</span><span class="token punctuation">;</span>      btn_insert.setOnClickListener<span class="token punctuation">(</span>this<span class="token punctuation">)</span><span class="token punctuation">;</span>      btn_delete.setOnClickListener<span class="token punctuation">(</span>this<span class="token punctuation">)</span><span class="token punctuation">;</span>      btn_select.setOnClickListener<span class="token punctuation">(</span>this<span class="token punctuation">)</span><span class="token punctuation">;</span>      btn_update.setOnClickListener<span class="token punctuation">(</span>this<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre></li></ul><h6 id="2-3-2-创建数据库"><a href="#2-3-2-创建数据库" class="headerlink" title="2.3.2 创建数据库"></a>2.3.2 创建数据库</h6><pre class=" language-bash"><code class="language-bash">//第一，自定义类继承SQLiteOpenHelper ，重写onCreate和onUpgrade方法public class MySQLiteHelper extends SQLiteOpenHelper <span class="token punctuation">{</span>    private Context mContext<span class="token punctuation">;</span>    public static final String CREATE_BOOK <span class="token operator">=</span> <span class="token string">"create table Book ("</span> +            <span class="token string">"id integer primary key autoincrement, "</span> +            <span class="token string">"author text, "</span> +            <span class="token string">"price real, "</span> +            <span class="token string">"pages integer, "</span> +            <span class="token string">"name text)"</span><span class="token punctuation">;</span>    public MySQLiteHelper<span class="token punctuation">(</span>Context context,String name,SQLiteDatabase.CursorFactory factory, int version<span class="token punctuation">)</span> <span class="token punctuation">{</span>        super<span class="token punctuation">(</span>context, name, factory, version<span class="token punctuation">)</span><span class="token punctuation">;</span>        mContext <span class="token operator">=</span> context<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    //该方法用于创建数据库，如果已存在则不会再创建    @Override    public void onCreate<span class="token punctuation">(</span>SQLiteDatabase db<span class="token punctuation">)</span> <span class="token punctuation">{</span>        db.execSQL<span class="token punctuation">(</span>CREATE_BOOK<span class="token punctuation">)</span><span class="token punctuation">;</span>        Toast.makeText<span class="token punctuation">(</span>mContext, <span class="token string">"create succeeded"</span>, Toast.LENGTH_SHORT<span class="token punctuation">)</span>.show<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    @Override    public void onUpgrade<span class="token punctuation">(</span>SQLiteDatabase db, int oldVersion, int newVersion<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>//activity里面的点击事件<span class="token keyword">case</span> R.id.btn_create:      //getWritableDatabase与getReadableDatabase方法的区别在于，当数据库不可写入的时候（如磁盘空间已满），getReadableDatabase方法返回的对象将以只读的方式去打开数据库，而getWritableDatabase方法则将抛出异常     db <span class="token operator">=</span> helper.getWritableDatabase<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">break</span><span class="token punctuation">;</span></code></pre><h6 id="2-3-3-升级数据库"><a href="#2-3-3-升级数据库" class="headerlink" title="2.3.3 升级数据库"></a>2.3.3 升级数据库</h6><p><img src="https://upload-images.jianshu.io/upload_images/15623160-658fbc1c83c454fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>重新写好MySQLiteHelper之后，只需在new MySQLiteHelper的最后一个参数里面传入一个比之前大的数，再调用getWritableDatabase或getReadableDatabase方法即可升级数据库了。</p><h6 id="2-3-4-增删查改"><a href="#2-3-4-增删查改" class="headerlink" title="2.3.4 增删查改"></a>2.3.4 增删查改</h6><pre class=" language-bash"><code class="language-bash">//增加数据<span class="token keyword">case</span> R.id.btn_insert:    ContentValues values <span class="token operator">=</span> new ContentValues<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    //组装第一条数据    values.put<span class="token punctuation">(</span><span class="token string">"name"</span>,<span class="token string">"LongSh1z"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    values.put<span class="token punctuation">(</span><span class="token string">"author"</span>,<span class="token string">"anthony"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    values.put<span class="token punctuation">(</span><span class="token string">"pages"</span>,454<span class="token punctuation">)</span><span class="token punctuation">;</span>    values.put<span class="token punctuation">(</span><span class="token string">"price"</span>,16.8<span class="token punctuation">)</span><span class="token punctuation">;</span>    //第一个参数是要插入的表的名称，    //第二个用于在未指定添加数据的情况下给某些可为空的列自动赋值NULL，    //第三个参数是要插入的数据    db.insert<span class="token punctuation">(</span><span class="token string">"Book"</span>,null,values<span class="token punctuation">)</span><span class="token punctuation">;</span> //向数据库插入数据    values.clear<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//清空values    //组装第二条数据    values.put<span class="token punctuation">(</span><span class="token string">"name"</span>,<span class="token string">"haha"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    values.put<span class="token punctuation">(</span><span class="token string">"author"</span>,<span class="token string">"David"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    values.put<span class="token punctuation">(</span><span class="token string">"pages"</span>,65<span class="token punctuation">)</span><span class="token punctuation">;</span>    values.put<span class="token punctuation">(</span><span class="token string">"price"</span>,15<span class="token punctuation">)</span><span class="token punctuation">;</span>    db.insert<span class="token punctuation">(</span><span class="token string">"Book"</span>,null,values<span class="token punctuation">)</span><span class="token punctuation">;</span> //向数据库插入数据<span class="token keyword">break</span><span class="token punctuation">;</span>//删除数据<span class="token keyword">case</span> R.id.btn_delete:    //第一个参数是表名    //第二和三个是要删除数据的条件，比如这里的意思就是要删除pages大于100的记录    db.delete<span class="token punctuation">(</span><span class="token string">"Book"</span>,<span class="token string">"pages > ?"</span>,new String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">"100"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span>//查询数据<span class="token keyword">case</span> R.id.btn_select:    //除了第一个参数是表名之外，其他的都是约束条件    Cursor cursor <span class="token operator">=</span> db.query<span class="token punctuation">(</span><span class="token string">"Book"</span>, null, null, null, null, null, null, null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cursor.moveToNext<span class="token punctuation">(</span><span class="token punctuation">))</span> <span class="token punctuation">{</span>            String name <span class="token operator">=</span> cursor.getString<span class="token punctuation">(</span>cursor.getColumnIndex<span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">))</span><span class="token punctuation">;</span>            String author <span class="token operator">=</span> cursor.getString<span class="token punctuation">(</span>cursor.getColumnIndex<span class="token punctuation">(</span><span class="token string">"author"</span><span class="token punctuation">))</span><span class="token punctuation">;</span>            int pages <span class="token operator">=</span> cursor.getInt<span class="token punctuation">(</span>cursor.getColumnIndex<span class="token punctuation">(</span><span class="token string">"pages"</span><span class="token punctuation">))</span><span class="token punctuation">;</span>            Log.i<span class="token punctuation">(</span><span class="token string">"MainActivity"</span>, <span class="token string">"name: "</span> + name<span class="token punctuation">)</span><span class="token punctuation">;</span>            Log.i<span class="token punctuation">(</span><span class="token string">"MainActivity"</span>, <span class="token string">"author: "</span> + author<span class="token punctuation">)</span><span class="token punctuation">;</span>            Log.i<span class="token punctuation">(</span><span class="token string">"MainActivity"</span>, <span class="token string">"pages: "</span> + pages<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      cursor.close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//记得关闭cursor，不然会造成内存泄漏<span class="token keyword">break</span><span class="token punctuation">;</span>//更改数据<span class="token keyword">case</span> R.id.btn_update:        ContentValues values1 <span class="token operator">=</span> new ContentValues<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        values1.put<span class="token punctuation">(</span><span class="token string">"price"</span>,10.47<span class="token punctuation">)</span><span class="token punctuation">;</span>        //第一个参数是表名，第二和第三是约束条件        db.update<span class="token punctuation">(</span><span class="token string">"Book"</span>,values1,<span class="token string">"name = ?"</span>,new String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">"haha"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span></code></pre><h5 id="2-4-注意"><a href="#2-4-注意" class="headerlink" title="2.4 注意"></a>2.4 注意</h5><p>① 其实，也可以直接用SQL语句来完成增删查改的功能：</p><pre class=" language-bash"><code class="language-bash">db.execSQL<span class="token punctuation">(</span><span class="token string">"insert into Book (name,author,pages,price) values (?,?,?,?)"</span>,             new String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span> <span class="token string">"john"</span> , <span class="token string">"Smith"</span>, <span class="token string">"123"</span>, <span class="token string">"7.5"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>db.execSQL<span class="token punctuation">(</span><span class="token string">"delete from Book where pages > ?"</span> , new String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span> <span class="token string">"400"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>db.rawQuery<span class="token punctuation">(</span><span class="token string">"select * from Book"</span> , null<span class="token punctuation">)</span><span class="token punctuation">;</span>db.execSQL<span class="token punctuation">(</span><span class="token string">"update Book set price = ? "</span> , new String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span> <span class="token string">"32"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>② SQLite的事务处理是如何做的？<br>SQLite在做CRUD操作时都默认开启了事务，然后把SQL语句翻译成对应的SQLiteStatement，并调用其相应的CRUD方法，此时整个操作还是在roolback journal这个临时文件上进行，只有操作顺利完成才能更新.db数据库，否则会回滚。</p><p>③ 怎么使用SQLite更好的做批量操作<br>使用SQLiteDatabase的beginTransaction方法开启一个事务，将批量操作SQL语句转化成SQLiteStatement，并进行批量操作，结束后endTransaction</p><pre class=" language-bash"><code class="language-bash">db.beginTransaction<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>try<span class="token punctuation">{</span>    db.execSQL<span class="token punctuation">(</span><span class="token punctuation">..</span>.<span class="token punctuation">)</span><span class="token punctuation">;</span>    db.execSQL<span class="token punctuation">(</span><span class="token punctuation">..</span>.<span class="token punctuation">)</span><span class="token punctuation">;</span>    db.setTransactionSuccessful<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>catch<span class="token punctuation">(</span><span class="token punctuation">..</span>.<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">..</span>.<span class="token punctuation">}</span>finally<span class="token punctuation">{</span>    db.endTransaction<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>④ 怎么删除表中的一个字段<br>SQLite数据库只允许增加表字段而不允许修改和删除表字段，只能采取复制表的思想，即创建一个新表保留原表想要的字段，再将原表删除。</p><p>⑤ 使用SQLite时有什么优化操作</p><ul><li>使用事务做批量处理</li><li>及时关闭cursor，避免内存泄露</li><li>耗时操作异步化，数据库的操作属于本地IO，通常比较耗时，建议放入异步线程中处理</li><li>ContentValues的容量调整，ContentValues内部采用HashMap来存储数据，ContentValues初始容量为8，扩容时翻倍。因此建议提前估量要填入的数据，设置合理的初始化容量，避免不必要的扩容操作。</li><li>使用索引加快检索速度，对于查询操作量较大，业务对查询要求较大的推荐使用索引</li></ul><h3 id="三、运行时权限"><a href="#三、运行时权限" class="headerlink" title="三、运行时权限"></a>三、运行时权限</h3><h5 id="3-1-前言"><a href="#3-1-前言" class="headerlink" title="3.1 前言"></a>3.1 前言</h5><p>运行时权限是Android开发团队在<strong>Android 6.0（API 23）</strong>系统中引入的功能，用户不需要在安装软件的时候一次性授权所有申请的权限，而是可以在软件的使用过程中再对某一项权限申请授权，这样可以更好的保护了用户的安全和隐私。</p><h5 id="3-2-分类"><a href="#3-2-分类" class="headerlink" title="3.2 分类"></a>3.2 分类</h5><p>Android现在将所有权限分成了两类，一类是普通权限。另一类是危险权限。</p><blockquote><p>第三类特殊权限就不讨论了，如下：<br><strong>SYSTEM_ALERT_WINDOW</strong> 系统级别对话框<br><strong>WRITE_SETTINGS</strong> 修改系统设置</p></blockquote><ul><li><strong>普通权限</strong><br>它指的是那些不会直接威胁到用户安全和隐私的权限，对于这部分权限，系统会自动帮我们授权，而不需要用户再去手动授权了。除了危险权限之外，剩余的都是普通权限。</li><li><strong>危险权限</strong><br>它表示那些可能会威胁到用户安全和隐私的权限，对于这部分权限，需要用户手动去授权才可以。<br>该部分权限如下（9组24个权限）：<pre class=" language-bash"><code class="language-bash">group:android.permission-group.CONTACTSpermission:android.permission.WRITE_CONTACTSpermission:android.permission.GET_ACCOUNTSpermission:android.permission.READ_CONTACTS</code></pre></li></ul><p>group:android.permission-group.PHONE<br>permission:android.permission.READ_CALL_LOG<br>permission:android.permission.READ_PHONE_STATE<br>permission:android.permission.CALL_PHONE<br>permission:android.permission.WRITE_CALL_LOG<br>permission:android.permission.USE_SIP<br>permission:android.permission.PROCESS_OUTGOING_CALLS<br>permission:com.android.voicemail.permission.ADD_VOICEMAIL</p><p>group:android.permission-group.CALENDAR<br>permission:android.permission.READ_CALENDAR<br>permission:android.permission.WRITE_CALENDAR</p><p>group:android.permission-group.CAMERA<br>permission:android.permission.CAMERA</p><p>group:android.permission-group.SENSORS<br>permission:android.permission.BODY_SENSORS</p><p>group:android.permission-group.LOCATION<br>permission:android.permission.ACCESS_FINE_LOCATION<br>permission:android.permission.ACCESS_COARSE_LOCATION</p><p>group:android.permission-group.STORAGE<br>permission:android.permission.READ_EXTERNAL_STORAGE<br>permission:android.permission.WRITE_EXTERNAL_STORAGE</p><p>group:android.permission-group.MICROPHONE<br>permission:android.permission.RECORD_AUDIO</p><p>group:android.permission-group.SMS<br>permission:android.permission.READ_SMS<br>permission:android.permission.RECEIVE_WAP_PUSH<br>permission:android.permission.RECEIVE_MMS<br>permission:android.permission.RECEIVE_SMS<br>permission:android.permission.SEND_SMS</p><pre><code>##### 3.3 注意上述的每一个危险权限都属于对应的一个权限组，我们在进行运行时权限处理时使用的是权限名，但是用户一旦授权了，那么该权限所在权限组中的所有其他权限也会同时被授权。##### 3.4 小案例比如我们点击按钮之后要实现打电话的功能，因为电话权限属于危险权限，所以我们在6.0以上的手机运行时需要先询问用户是否同意授权。```bash@Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main6);        button = findViewById(R.id.button);        button.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                //先检查打电话权限是否已经被授权                //第一个参数是context，第二个是需要授权的权限                if (ContextCompat.checkSelfPermission(Main6Activity.this, Manifest.permission.CALL_PHONE)                                                       != PackageManager.PERMISSION_GRANTED){                    //如果该权限还未授权，系统会弹出一个申请权限的对话框                    //不管用户选择哪项，都会调用下面重写的onRequestPermissionsResult方法                    ActivityCompat.requestPermissions(Main6Activity.this,                                                      new String[]{ Manifest.permission.CALL_PHONE },1);                }else {                    call();                }            }        });    }    private void call(){        //打电话        Intent intent = new Intent(Intent.ACTION_CALL);        intent.setData(Uri.parse("tel:10086"));        startActivity(intent);    }    @Override    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {        switch (requestCode){            case 1:                if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED){                    call();                }else {                    Toast.makeText(this, "您已拒绝该权限，请前往设置开启！", Toast.LENGTH_SHORT).show();                }                break;        }    }</code></pre><h3 id="四、访问其他程序中的数据"><a href="#四、访问其他程序中的数据" class="headerlink" title="四、访问其他程序中的数据"></a>四、访问其他程序中的数据</h3><h5 id="4-1-前言"><a href="#4-1-前言" class="headerlink" title="4.1 前言"></a>4.1 前言</h5><p>Android系统中自带的电话簿、短信、媒体库等程序都提供了这样的内容提供器供外界访问。</p><h5 id="4-2-ContentResolver"><a href="#4-2-ContentResolver" class="headerlink" title="4.2 ContentResolver"></a>4.2 ContentResolver</h5><ul><li>每个应用程序要想访问内容提供器中的数据，就一定要借助ContentResolver类，可以通过Context中的<strong>getContentResolver</strong>方法来获取。ContentResolver类提供了一系列方法用于对数据进行CRUD操作，<strong>insert</strong>方法用于添加数据，<strong>update</strong>方法用于更新数据，<strong>delete</strong>方法用于删除数据，<strong>query</strong>方法用于查询数据。它和SQLiteDatabase很像，只不过它不接收表名，而是换成了Uri参数。</li><li>Uri包括两部分：authority和path。authority命名为 <strong>包名.provider</strong>，path命名为 <strong>表名</strong> ，所以一个标准的Uri可以为<strong>content://com.example.testspecial.provider/table1</strong></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/15623160-35f0c70d237ae66a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p>除此之外，我们还可以在这个Uri的后面加上一个id，如下所示<br><strong>content://com.example.testspecial.provider/table1/1</strong><br>它表示调用方希望访问的是com.example.testspecial这个应用的table1表中id为1的数据。</p></blockquote><p>我们得到内容Uri字符串之后，还需要将其转化为Uri对象才可以作为参数传入。</p><pre class=" language-bash"><code class="language-bash">Uri uri <span class="token operator">=</span> Uri.parse<span class="token punctuation">(</span><span class="token string">"content://com.example.testspecial.provider/table1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h6 id="4-2-1-增加数据"><a href="#4-2-1-增加数据" class="headerlink" title="4.2.1 增加数据"></a>4.2.1 增加数据</h6><pre class=" language-bash"><code class="language-bash">ContentValues values <span class="token operator">=</span> new ContentValues<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>values.put<span class="token punctuation">(</span><span class="token string">"column1"</span> , <span class="token string">"text"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>values.put<span class="token punctuation">(</span><span class="token string">"column2"</span> , 1<span class="token punctuation">)</span><span class="token punctuation">;</span>getContentResolver<span class="token punctuation">(</span><span class="token punctuation">)</span>.insert<span class="token punctuation">(</span>uri , values<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h6 id="4-2-2-删除数据"><a href="#4-2-2-删除数据" class="headerlink" title="4.2.2 删除数据"></a>4.2.2 删除数据</h6><pre class=" language-bash"><code class="language-bash">getContentResolver<span class="token punctuation">(</span><span class="token punctuation">)</span>.delete<span class="token punctuation">(</span>uri , <span class="token string">"column2 = ? "</span> , new String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span> <span class="token string">"1"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h6 id="4-2-3-查询数据"><a href="#4-2-3-查询数据" class="headerlink" title="4.2.3 查询数据"></a>4.2.3 查询数据</h6><pre class=" language-bash"><code class="language-bash">Cursor cursor <span class="token operator">=</span> getContentResolver<span class="token punctuation">(</span><span class="token punctuation">)</span>.query<span class="token punctuation">(</span>                uri,  //该参数是一个Uri对象                projection,  //该参数指定查询的列名                selection,  //该参数指定where的约束条件                sortOrder<span class="token punctuation">)</span><span class="token punctuation">;</span>  //该参数指定查询结果的排序方式if<span class="token punctuation">(</span>cursor <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>    while<span class="token punctuation">(</span>cursor.moveToNext<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">{</span>        String column1 <span class="token operator">=</span> cursor.getString<span class="token punctuation">(</span> cursor.getColumnIndex<span class="token punctuation">(</span><span class="token string">"column1"</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        int column2 <span class="token operator">=</span> cursor.getInt<span class="token punctuation">(</span> cursor.getColumnIndex<span class="token punctuation">(</span><span class="token string">"column2"</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cursor.close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h6 id="4-2-4-修改数据"><a href="#4-2-4-修改数据" class="headerlink" title="4.2.4 修改数据"></a>4.2.4 修改数据</h6><p>比如我们把column1的数据改为”changed”，我们可以：</p><pre class=" language-bash"><code class="language-bash">ContentValues values <span class="token operator">=</span> new ContentValues<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>values.put<span class="token punctuation">(</span><span class="token string">"column1"</span> , <span class="token string">"changed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>getContentResolver<span class="token punctuation">(</span><span class="token punctuation">)</span>.update<span class="token punctuation">(</span>uri , values, <span class="token string">"column1 = ? and column2 = ? "</span>, new String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span> <span class="token string">"text"</span> , <span class="token string">"1"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="4-3-小案例"><a href="#4-3-小案例" class="headerlink" title="4.3 小案例"></a>4.3 小案例</h5><p>这里我们实现读取手机里联系人的功能</p><pre class=" language-bash"><code class="language-bash">public class Main6Activity extends AppCompatActivity <span class="token punctuation">{</span>    private ListView listView<span class="token punctuation">;</span>    ArrayAdapter<span class="token operator">&lt;</span>String<span class="token operator">></span> adapter<span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>String<span class="token operator">></span> contactsList <span class="token operator">=</span> new ArrayList<span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    @Override    protected void onCreate<span class="token punctuation">(</span>Bundle savedInstanceState<span class="token punctuation">)</span> <span class="token punctuation">{</span>        super.onCreate<span class="token punctuation">(</span>savedInstanceState<span class="token punctuation">)</span><span class="token punctuation">;</span>        setContentView<span class="token punctuation">(</span>R.layout.activity_main6<span class="token punctuation">)</span><span class="token punctuation">;</span>        listView <span class="token operator">=</span> findViewById<span class="token punctuation">(</span>R.id.listView<span class="token punctuation">)</span><span class="token punctuation">;</span>        adapter <span class="token operator">=</span> new ArrayAdapter<span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>this,android.R.layout.simple_list_item_1,contactsList<span class="token punctuation">)</span><span class="token punctuation">;</span>        listView.setAdapter<span class="token punctuation">(</span>adapter<span class="token punctuation">)</span><span class="token punctuation">;</span>        //先检查权限是否已经被授权        <span class="token keyword">if</span> <span class="token punctuation">(</span>ContextCompat.checkSelfPermission<span class="token punctuation">(</span>Main6Activity.this, Manifest.permission.READ_CONTACTS<span class="token punctuation">)</span> <span class="token operator">!=</span> PackageManager.PERMISSION_GRANTED<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ActivityCompat.requestPermissions<span class="token punctuation">(</span>Main6Activity.this, new String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>Manifest.permission.READ_CONTACTS<span class="token punctuation">}</span>, 1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            readContacts<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    private void readContacts<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Cursor cursor <span class="token operator">=</span> null<span class="token punctuation">;</span>        try <span class="token punctuation">{</span>            //ContactsContract.CommonDataKinds.Phone类已经帮我们封装好了，提供了一个CONTENT_URI常量，它就是一个Uri对象            cursor <span class="token operator">=</span> getContentResolver<span class="token punctuation">(</span><span class="token punctuation">)</span>.query<span class="token punctuation">(</span>ContactsContract.CommonDataKinds.Phone.CONTENT_URI,null,null,null<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cursor <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>cursor.moveToNext<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">{</span>                    String name <span class="token operator">=</span> cursor.getString<span class="token punctuation">(</span>cursor.getColumnIndex<span class="token punctuation">(</span>ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME<span class="token punctuation">))</span><span class="token punctuation">;</span>                    String number <span class="token operator">=</span> cursor.getString<span class="token punctuation">(</span>cursor.getColumnIndex<span class="token punctuation">(</span>ContactsContract.CommonDataKinds.Phone.NUMBER<span class="token punctuation">))</span><span class="token punctuation">;</span>                    contactsList.add<span class="token punctuation">(</span>name + <span class="token string">"\n"</span> + number<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                //通知listView数据已改变                adapter.notifyDataSetChanged<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>catch <span class="token punctuation">(</span>Exception e<span class="token punctuation">)</span><span class="token punctuation">{</span>            e.printStackTrace<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>finally <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cursor <span class="token operator">!=</span> null<span class="token punctuation">)</span> cursor.close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    @Override    public void onRequestPermissionsResult<span class="token punctuation">(</span>int requestCode, @NonNull String<span class="token punctuation">[</span><span class="token punctuation">]</span> permissions, @NonNull int<span class="token punctuation">[</span><span class="token punctuation">]</span> grantResults<span class="token punctuation">)</span> <span class="token punctuation">{</span>        switch <span class="token punctuation">(</span>requestCode<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">case</span> 1:                <span class="token keyword">if</span> <span class="token punctuation">(</span>grantResults.length <span class="token operator">></span> 0 <span class="token operator">&amp;&amp;</span> grantResults<span class="token punctuation">[</span>0<span class="token punctuation">]</span> <span class="token operator">==</span> PackageManager.PERMISSION_GRANTED<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    readContacts<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    Toast.makeText<span class="token punctuation">(</span>this, <span class="token string">"您已拒绝该权限，请前往设置开启！"</span>, Toast.LENGTH_SHORT<span class="token punctuation">)</span>.show<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><img src="https://upload-images.jianshu.io/upload_images/15623160-34d4342c96277695.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="五、创建自己的内容提供器"><a href="#五、创建自己的内容提供器" class="headerlink" title="五、创建自己的内容提供器"></a>五、创建自己的内容提供器</h3><h5 id="5-1-前言"><a href="#5-1-前言" class="headerlink" title="5.1 前言"></a>5.1 前言</h5><p>整体思路：<br>首先，自定义类继承ContentProvider。<br>然后，重写onCreate、query、insert、update、delete、getType方法。<br>最后，记得在AndroidManifest文件中注册该content provider。</p><h5 id="5-2-实例"><a href="#5-2-实例" class="headerlink" title="5.2 实例"></a>5.2 实例</h5><pre class=" language-bash"><code class="language-bash">public class MyProvider extends ContentProvider <span class="token punctuation">{</span>    public static final int BOOK_DIR <span class="token operator">=</span> 0<span class="token punctuation">;</span> //代表访问Book表的所有数据    public static final int BOOK_ITEM <span class="token operator">=</span> 1<span class="token punctuation">;</span> //代表访问Book表的单条数据    public static final int CATEGORY_DIR <span class="token operator">=</span> 2<span class="token punctuation">;</span>    public static final int CATEGORY_ITEM <span class="token operator">=</span> 3<span class="token punctuation">;</span>    public static final String AUTHORITY <span class="token operator">=</span> <span class="token string">"com.example.testspecial.provider"</span><span class="token punctuation">;</span>    private static UriMatcher uriMatcher<span class="token punctuation">;</span> //UriMatcher类可以实现匹配Uri的功能    private MySQLiteHelper sqLiteHelper<span class="token punctuation">;</span>    static <span class="token punctuation">{</span>        uriMatcher <span class="token operator">=</span> new UriMatcher<span class="token punctuation">(</span>UriMatcher.NO_MATCH<span class="token punctuation">)</span><span class="token punctuation">;</span>        uriMatcher.addURI<span class="token punctuation">(</span>AUTHORITY,<span class="token string">"book"</span>,BOOK_DIR<span class="token punctuation">)</span><span class="token punctuation">;</span> //如果uriMatcher.match<span class="token punctuation">(</span>uri<span class="token punctuation">)</span>匹配这个URI，就返回BOOK_DIR        uriMatcher.addURI<span class="token punctuation">(</span>AUTHORITY,<span class="token string">"book/#"</span>,BOOK_ITEM<span class="token punctuation">)</span><span class="token punctuation">;</span>        uriMatcher.addURI<span class="token punctuation">(</span>AUTHORITY,<span class="token string">"category"</span>,CATEGORY_DIR<span class="token punctuation">)</span><span class="token punctuation">;</span>        uriMatcher.addURI<span class="token punctuation">(</span>AUTHORITY,<span class="token string">"category/#"</span>,CATEGORY_ITEM<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    public MyProvider<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    //初始化内容提供器的时候调用，通常会在这里完成对数据库的创建和升级等操作，返回true表示初始化成功，反之失败。    @Override    public boolean onCreate<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        // TODO: Implement this to initialize your content provider on startup.        sqLiteHelper <span class="token operator">=</span> new MySQLiteHelper<span class="token punctuation">(</span>getContext<span class="token punctuation">(</span><span class="token punctuation">)</span>,<span class="token string">"BookStore.db"</span>,null,2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    //从内容提供器中查询数据，查到的内容放在cursor中返回    @Override    public Cursor query<span class="token punctuation">(</span>Uri uri, String<span class="token punctuation">[</span><span class="token punctuation">]</span> projection, String selection,                        String<span class="token punctuation">[</span><span class="token punctuation">]</span> selectionArgs, String sortOrder<span class="token punctuation">)</span> <span class="token punctuation">{</span>        // TODO: Implement this to handle query requests from clients.        SQLiteDatabase db <span class="token operator">=</span> sqLiteHelper.getReadableDatabase<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Cursor cursor <span class="token operator">=</span> null<span class="token punctuation">;</span>        switch <span class="token punctuation">(</span>uriMatcher.match<span class="token punctuation">(</span>uri<span class="token punctuation">))</span><span class="token punctuation">{</span>            <span class="token keyword">case</span> BOOK_DIR:                cursor <span class="token operator">=</span> db.query<span class="token punctuation">(</span><span class="token string">"Book"</span>,projection,selection,selectionArgs,null,null,sortOrder<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> BOOK_ITEM:                String bookId <span class="token operator">=</span> uri.getPathSegments<span class="token punctuation">(</span><span class="token punctuation">)</span>.get<span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span>                cursor <span class="token operator">=</span> db.query<span class="token punctuation">(</span><span class="token string">"Book"</span>,projection,<span class="token string">"id = ?"</span>,new String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>bookId<span class="token punctuation">}</span>,null,null,sortOrder<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> CATEGORY_DIR:                cursor <span class="token operator">=</span> db.query<span class="token punctuation">(</span><span class="token string">"Category"</span>,projection,selection,selectionArgs,null,null,sortOrder<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> CATEGORY_ITEM:                String categoryId <span class="token operator">=</span> uri.getPathSegments<span class="token punctuation">(</span><span class="token punctuation">)</span>.get<span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span>                cursor <span class="token operator">=</span> db.query<span class="token punctuation">(</span><span class="token string">"Category"</span>,projection,<span class="token string">"id = ?"</span>,new String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>categoryId<span class="token punctuation">}</span>,null,null,sortOrder<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> cursor<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    //根据传入的内容URI来返回相应的MIME类型。    //一个内容URI所对应的MIME字符串主要由三部分组分。    //Android对这三个部分做了以下格式规定：必须以vnd开头；如果内容URI以路径结尾，    //则后接android.cursor.dir/，如果内容URI以id结尾，则后接android.cursor.item/；    //最后接上vnd.<span class="token operator">&lt;</span> authority<span class="token operator">></span>.<span class="token operator">&lt;</span> path<span class="token operator">></span>    @Override    public String getType<span class="token punctuation">(</span>Uri uri<span class="token punctuation">)</span> <span class="token punctuation">{</span>        // TODO: Implement this to handle requests <span class="token keyword">for</span> the MIME <span class="token function">type</span> of the data        // at the given URI.        switch <span class="token punctuation">(</span>uriMatcher.match<span class="token punctuation">(</span>uri<span class="token punctuation">))</span><span class="token punctuation">{</span>            <span class="token keyword">case</span> BOOK_DIR:                <span class="token keyword">return</span> <span class="token string">"vnd.android.cursor.dir/vnd.com.example.testspecial.provider.book"</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> BOOK_ITEM:                <span class="token keyword">return</span> <span class="token string">"vnd.android.cursor.item/vnd.com.example.testspecial.provider.book"</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> CATEGORY_DIR:                <span class="token keyword">return</span> <span class="token string">"vnd.android.cursor.dir/vnd.com.example.testspecial.provider.category"</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> CATEGORY_ITEM:                <span class="token keyword">return</span> <span class="token string">"vnd.android.cursor.item/vnd.com.example.testspecial.provider.category"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    //向内容提供器中添加一条数据，返回一个用于表示这条新纪录的URI    @Override    public Uri insert<span class="token punctuation">(</span>Uri uri, ContentValues values<span class="token punctuation">)</span> <span class="token punctuation">{</span>        // TODO: Implement this to handle requests to insert a new row.        SQLiteDatabase db <span class="token operator">=</span> sqLiteHelper.getWritableDatabase<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Uri uriReturn <span class="token operator">=</span> null<span class="token punctuation">;</span>        switch <span class="token punctuation">(</span>uriMatcher.match<span class="token punctuation">(</span>uri<span class="token punctuation">))</span><span class="token punctuation">{</span>            <span class="token keyword">case</span> BOOK_DIR:            <span class="token keyword">case</span> BOOK_ITEM:                long newBookId <span class="token operator">=</span> db.insert<span class="token punctuation">(</span><span class="token string">"Book"</span>,null,values<span class="token punctuation">)</span><span class="token punctuation">;</span>                uriReturn <span class="token operator">=</span> Uri.parse<span class="token punctuation">(</span><span class="token string">"content://"</span> + AUTHORITY + <span class="token string">"/book/"</span> + newBookId<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> CATEGORY_DIR:            <span class="token keyword">case</span> CATEGORY_ITEM:                long newCategoryId <span class="token operator">=</span> db.insert<span class="token punctuation">(</span><span class="token string">"Category"</span>,null,values<span class="token punctuation">)</span><span class="token punctuation">;</span>                uriReturn <span class="token operator">=</span> Uri.parse<span class="token punctuation">(</span><span class="token string">"content://"</span> + AUTHORITY + <span class="token string">"/category/"</span> + newCategoryId<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> uriReturn<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    //从内容提供器中删除数据，返回受影响的行数    @Override    public int delete<span class="token punctuation">(</span>Uri uri, String selection, String<span class="token punctuation">[</span><span class="token punctuation">]</span> selectionArgs<span class="token punctuation">)</span> <span class="token punctuation">{</span>        // Implement this to handle requests to delete one or <span class="token function">more</span> rows.        SQLiteDatabase db <span class="token operator">=</span> sqLiteHelper.getWritableDatabase<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        int deletedRows <span class="token operator">=</span> 0<span class="token punctuation">;</span>        switch <span class="token punctuation">(</span>uriMatcher.match<span class="token punctuation">(</span>uri<span class="token punctuation">))</span><span class="token punctuation">{</span>            <span class="token keyword">case</span> BOOK_DIR:                deletedRows <span class="token operator">=</span> db.delete<span class="token punctuation">(</span><span class="token string">"Book"</span>,selection,selectionArgs<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> BOOK_ITEM:                String bookId <span class="token operator">=</span> uri.getPathSegments<span class="token punctuation">(</span><span class="token punctuation">)</span>.get<span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span>                deletedRows <span class="token operator">=</span> db.delete<span class="token punctuation">(</span><span class="token string">"Book"</span>,<span class="token string">"id = ?"</span>,new String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>bookId<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> CATEGORY_DIR:                deletedRows <span class="token operator">=</span> db.delete<span class="token punctuation">(</span><span class="token string">"Category"</span>,selection,selectionArgs<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> CATEGORY_ITEM:                String categoryId <span class="token operator">=</span> uri.getPathSegments<span class="token punctuation">(</span><span class="token punctuation">)</span>.get<span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span>                deletedRows <span class="token operator">=</span> db.delete<span class="token punctuation">(</span><span class="token string">"Category"</span>,<span class="token string">"id = ?"</span>,new String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>categoryId<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> deletedRows<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    //更新内容提供器中已有的数据，返回受影响的行数    @Override    public int update<span class="token punctuation">(</span>Uri uri, ContentValues values, String selection,                      String<span class="token punctuation">[</span><span class="token punctuation">]</span> selectionArgs<span class="token punctuation">)</span> <span class="token punctuation">{</span>        // TODO: Implement this to handle requests to update one or <span class="token function">more</span> rows.        SQLiteDatabase db <span class="token operator">=</span> sqLiteHelper.getWritableDatabase<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        int updateRows <span class="token operator">=</span> 0<span class="token punctuation">;</span>        switch <span class="token punctuation">(</span>uriMatcher.match<span class="token punctuation">(</span>uri<span class="token punctuation">))</span><span class="token punctuation">{</span>            <span class="token keyword">case</span> BOOK_DIR:                updateRows <span class="token operator">=</span> db.update<span class="token punctuation">(</span><span class="token string">"Book"</span>,values,selection,selectionArgs<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> BOOK_ITEM:                String bookId <span class="token operator">=</span> uri.getPathSegments<span class="token punctuation">(</span><span class="token punctuation">)</span>.get<span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span>                updateRows <span class="token operator">=</span> db.update<span class="token punctuation">(</span><span class="token string">"Book"</span>,values,<span class="token string">"id = ?"</span>,new String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>bookId<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> CATEGORY_DIR:                updateRows <span class="token operator">=</span> db.update<span class="token punctuation">(</span><span class="token string">"Category"</span>,values,selection,selectionArgs<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> CATEGORY_ITEM:                String categoryId <span class="token operator">=</span> uri.getPathSegments<span class="token punctuation">(</span><span class="token punctuation">)</span>.get<span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span>                updateRows <span class="token operator">=</span> db.update<span class="token punctuation">(</span><span class="token string">"Category"</span>,values,<span class="token string">"id = ?"</span>,new String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>categoryId<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> updateRows<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>然后我们在另外一个项目中访问上面的content provider。</p><pre class=" language-bash"><code class="language-bash">public class MainActivity extends AppCompatActivity implements View.OnClickListener <span class="token punctuation">{</span>    private Button btn_insert,btn_delete,btn_select,btn_update<span class="token punctuation">;</span>    private String newId<span class="token punctuation">;</span>    @Override    protected void onCreate<span class="token punctuation">(</span>Bundle savedInstanceState<span class="token punctuation">)</span> <span class="token punctuation">{</span>        super.onCreate<span class="token punctuation">(</span>savedInstanceState<span class="token punctuation">)</span><span class="token punctuation">;</span>        setContentView<span class="token punctuation">(</span>R.layout.activity_main<span class="token punctuation">)</span><span class="token punctuation">;</span>        btn_insert <span class="token operator">=</span> findViewById<span class="token punctuation">(</span>R.id.btn_insert<span class="token punctuation">)</span><span class="token punctuation">;</span>        btn_delete <span class="token operator">=</span> findViewById<span class="token punctuation">(</span>R.id.btn_delete<span class="token punctuation">)</span><span class="token punctuation">;</span>        btn_select <span class="token operator">=</span> findViewById<span class="token punctuation">(</span>R.id.btn_select<span class="token punctuation">)</span><span class="token punctuation">;</span>        btn_update <span class="token operator">=</span> findViewById<span class="token punctuation">(</span>R.id.btn_update<span class="token punctuation">)</span><span class="token punctuation">;</span>        btn_insert.setOnClickListener<span class="token punctuation">(</span>this<span class="token punctuation">)</span><span class="token punctuation">;</span>        btn_delete.setOnClickListener<span class="token punctuation">(</span>this<span class="token punctuation">)</span><span class="token punctuation">;</span>        btn_select.setOnClickListener<span class="token punctuation">(</span>this<span class="token punctuation">)</span><span class="token punctuation">;</span>        btn_update.setOnClickListener<span class="token punctuation">(</span>this<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    @Override    public void onClick<span class="token punctuation">(</span>View v<span class="token punctuation">)</span> <span class="token punctuation">{</span>        switch <span class="token punctuation">(</span>v.getId<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">{</span>            <span class="token keyword">case</span> R.id.btn_insert:                Uri uri1 <span class="token operator">=</span> Uri.parse<span class="token punctuation">(</span><span class="token string">"content://com.example.testspecial.provider/book"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                ContentValues values <span class="token operator">=</span> new ContentValues<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                values.put<span class="token punctuation">(</span><span class="token string">"name"</span>,<span class="token string">"oiu"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                values.put<span class="token punctuation">(</span><span class="token string">"author"</span>,<span class="token string">"wef"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                values.put<span class="token punctuation">(</span><span class="token string">"pages"</span>,15<span class="token punctuation">)</span><span class="token punctuation">;</span>                Uri newUri <span class="token operator">=</span> getContentResolver<span class="token punctuation">(</span><span class="token punctuation">)</span>.insert<span class="token punctuation">(</span>uri1,values<span class="token punctuation">)</span><span class="token punctuation">;</span>                newId <span class="token operator">=</span> newUri.getPathSegments<span class="token punctuation">(</span><span class="token punctuation">)</span>.get<span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> R.id.btn_delete:                Uri uri2 <span class="token operator">=</span> Uri.parse<span class="token punctuation">(</span><span class="token string">"content://com.example.testspecial.provider/book/"</span>+newId<span class="token punctuation">)</span><span class="token punctuation">;</span>                getContentResolver<span class="token punctuation">(</span><span class="token punctuation">)</span>.delete<span class="token punctuation">(</span>uri2,null,null<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> R.id.btn_select:                Log.i<span class="token punctuation">(</span><span class="token string">"MainActivity"</span>, <span class="token string">"onClick: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                Uri uri <span class="token operator">=</span> Uri.parse<span class="token punctuation">(</span><span class="token string">"content://com.example.testspecial.provider/book"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                Cursor cursor <span class="token operator">=</span> getContentResolver<span class="token punctuation">(</span><span class="token punctuation">)</span>.query<span class="token punctuation">(</span>uri,null,null,null,null<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>cursor <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">while</span> <span class="token punctuation">(</span>cursor.moveToNext<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">{</span>                        String name <span class="token operator">=</span> cursor.getString<span class="token punctuation">(</span>cursor.getColumnIndex<span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">))</span><span class="token punctuation">;</span>                        String author <span class="token operator">=</span> cursor.getString<span class="token punctuation">(</span>cursor.getColumnIndex<span class="token punctuation">(</span><span class="token string">"author"</span><span class="token punctuation">))</span><span class="token punctuation">;</span>                        int pages <span class="token operator">=</span> cursor.getInt<span class="token punctuation">(</span>cursor.getColumnIndex<span class="token punctuation">(</span><span class="token string">"pages"</span><span class="token punctuation">))</span><span class="token punctuation">;</span>                        Log.i<span class="token punctuation">(</span><span class="token string">"MainActivity"</span>, <span class="token string">"name: "</span>+name+                                <span class="token string">"\n author: "</span>+author+                                <span class="token string">"\n pages: "</span>+pages<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    cursor.close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> R.id.btn_update:                Uri uri3 <span class="token operator">=</span> Uri.parse<span class="token punctuation">(</span><span class="token string">"content://com.example.testspecial.provider/book/"</span>+newId<span class="token punctuation">)</span><span class="token punctuation">;</span>                ContentValues values1 <span class="token operator">=</span> new ContentValues<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                values1.put<span class="token punctuation">(</span><span class="token string">"name"</span>,<span class="token string">"changedName"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                values1.put<span class="token punctuation">(</span><span class="token string">"author"</span>,<span class="token string">"changedAuthor"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                values1.put<span class="token punctuation">(</span><span class="token string">"pages"</span>,67<span class="token punctuation">)</span><span class="token punctuation">;</span>                getContentResolver<span class="token punctuation">(</span><span class="token punctuation">)</span>.update<span class="token punctuation">(</span>uri3,values1,null,null<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Content Provider </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四大组件之Service</title>
      <link href="/2020/03/21/si-da-zu-jian-zhi-service/"/>
      <url>/2020/03/21/si-da-zu-jian-zhi-service/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文目录结构：<br>一、服务简介<br>二、多线程编程<br>三、服务的生命周期<br>四、服务的基本用法<br>五、前台服务<br>六、如何保证service不被杀死</p></blockquote><h3 id="一、服务简介"><a href="#一、服务简介" class="headerlink" title="一、服务简介"></a>一、服务简介</h3><h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h5><p>服务在Android中的运用主要是实现任务在后台的运行，特别是那些不需要和用户交互而且还要求长期运行的任务，比如下载资源。服务的运行不依赖于任何用户界面，即使程序被切换到后台，或者用户打开了另外一个应用程序，服务仍然能够保持正常运行。</p><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><p>①服务并不是运行在一个独立的进程中的，而是依赖于创建服务时所在的应用进程。所以当该进程被杀掉时，所有依赖于该进程的服务也会停止运行。<br>②服务并不会自动开启线程，所有代码都是运行在主线程当中的。</p><h3 id="二、多线程编程"><a href="#二、多线程编程" class="headerlink" title="二、多线程编程"></a>二、多线程编程</h3><p>Android中的多线程主要有Thread与Handler的结合使用、AsyncTask、HandlerThread以及IntentService四种方式</p><h5 id="2-1-Thread与Handler的结合使用"><a href="#2-1-Thread与Handler的结合使用" class="headerlink" title="2.1 Thread与Handler的结合使用"></a>2.1 Thread与Handler的结合使用</h5><h6 id="2-1-1-创建方式"><a href="#2-1-1-创建方式" class="headerlink" title="2.1.1 创建方式"></a>2.1.1 创建方式</h6><p>Thread的创建方法我就不多讲了，在我的文章<a href="https://www.jianshu.com/p/652e54187fd6" target="_blank" rel="noopener">《那些你所不知道的Java小知识（持续更新）》</a>的第3点中可以看到。因为系统不建议在子线程中更新UI，但是有些时候我们必须在子线程里去执行一些耗时任务，然后根据任务的执行结果来更新相应的控件。因此Android为我们提供了一个<strong>异步消息处理机制</strong>。（至于为什么不建议，大家可以去看一下鸿洋的<a href="https://mp.weixin.qq.com/s/ZBHpbOj6cojvUCVZ5fAYBA" target="_blank" rel="noopener">《Android中子线程真的不能更新UI吗？》</a>，讲解的很详细）</p><h6 id="2-1-2-异步消息处理机制"><a href="#2-1-2-异步消息处理机制" class="headerlink" title="2.1.2 异步消息处理机制"></a>2.1.2 异步消息处理机制</h6><p>该机制主要由四个部分组成：Message，Handler，MessageQueue和Looper。</p><ul><li><p><strong>Message</strong> 是在线程之间传递的，它可以携带少量的信息，用于在不同线程之间交换数据。<strong>每个线程可以有多个Message对象</strong>。</p><blockquote><p>Message的创建方式有以下三种：<br>Message msg = new Message();<br>Message msg =Message.obtain();<br>Message msg = handler1.obtainMessage();<br>后两种方法都是从整个Message池中返回一个新的Message实例，能有效避免重复Message创建对象，因此更推荐后两种方法。</p></blockquote></li><li><p><strong>Handler</strong> 主要用于发送和处理Message。发送消息一般是使用Handler的sendMessage方法，消息经过一系列流程过后会传到Handler的handleMessage方法中。<strong>每个线程可以有多个Handler对象</strong>。</p></li><li><p><strong>MessageQueue</strong> 主要用于存储所有通过Handler发送的Message。<strong>每个线程只有一个MessageQueue对象</strong>。</p></li><li><p><strong>Looper</strong> 相当于MessageQueue的管家，当调用Looper的loop方法之后，就会进入一个无限循环当中，然后每当发现MessageQueue中存在一条消息，就会将它取出，并传递到Handler的handleMessage方法中。<strong>每个线程只有一个Looper对象</strong>。<br>所以它们四个的数量关系是：每个线程只能有一个Looper和一个MessageQueue，但是可以有多个Handler和多个Message。<br><img src="https://upload-images.jianshu.io/upload_images/15623160-2cb5361373a9e850.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="流程图"></p></li></ul><h6 id="2-1-3-小例子"><a href="#2-1-3-小例子" class="headerlink" title="2.1.3 小例子"></a>2.1.3 小例子</h6><p>这里我们实现点击按钮之后在子线程中更新按钮的文字。</p><p><img src="https://upload-images.jianshu.io/upload_images/15623160-58678c777354866e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="小例子.png"></p><h6 id="2-1-4-注意"><a href="#2-1-4-注意" class="headerlink" title="2.1.4 注意"></a>2.1.4 注意</h6><p>① 主线程中Looper的轮询死循环为什么没有阻塞主线程？<br>Android是依靠事件驱动的，通过Looper.loop()不断进行消息循环，可以说activity的生命周期都是运行在Looper.loop()的控制之下，一旦退出消息循环，应用也就退出了。<br>② 使用Handler的postDelay()后消息队列会发生什么变化？<br>postDelay的Message并不是先等待一定时间再放到MessageQueue中，而是直接放入并阻塞当前线程，然后将其delay的时间和队头的进行比较，按照触发时间进行排序，更近的则放入队头，保证队头的时间最小，队尾的最大。如果此时队头的Message正是被delay的，则将当前线程堵塞一段时间，直到等待足够的时间再唤醒执行该Message，否则唤醒后直接执行。</p><h5 id="2-2-AsyncTask"><a href="#2-2-AsyncTask" class="headerlink" title="2.2 AsyncTask"></a>2.2 AsyncTask</h5><h6 id="2-2-1-前言"><a href="#2-2-1-前言" class="headerlink" title="2.2.1 前言"></a>2.2.1 前言</h6><p>① AsyncTask的底层原理封装了线程池和Handler，在其之中有两个线程池：<strong>SerialExecutor</strong>用于任务的排队，默认是串行的线程池，在3.0以前核心线程数为5，线程池大小为128，而3.0以后改为同一时间只能处理一个任务；<strong>THREAD_POOL_EXECUTOR</strong>用于真正执行任务。<br>② AsyncTask是一个抽象类，使用前要先继承。（匿名内部类的方式除外）。</p><h6 id="2-2-2-参数和方法说明"><a href="#2-2-2-参数和方法说明" class="headerlink" title="2.2.2 参数和方法说明"></a>2.2.2 参数和方法说明</h6><p><img src="https://upload-images.jianshu.io/upload_images/15623160-4e0357d0bbfec2ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>① 在继承的时候我们需要指定三个参数，它们代表的意义如下：</p><ul><li><p><strong>Params</strong>：在执行AsyncTask时需要传入的参数，它可以在后台任务中使用。</p></li><li><p><strong>Progress</strong>：后台任务执行时，如果需要在界面上显示当前的进度，则使用这里指定的参数作为单位。</p></li><li><p><strong>Result</strong>：当后台任务执行完毕后，如果需要返回结果，则使用这里的参数作为返回类型。<br>所以，一个自定义的AsyncTask可以如下所示：</p><pre class=" language-bash"><code class="language-bash">public class MyTask extends AsyncTask<span class="token operator">&lt;</span>Void,Integer,Boolean<span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token punctuation">..</span>.<span class="token punctuation">}</span></code></pre><p>② 接着我们需要重写其中的几个方法：</p></li><li><p><strong>onPreExecute()</strong><br>这个方法会在后台任务开始执行之前调用，我们可以在这里进行一些界面上的初始化操作，比如显示一个对话框。</p></li><li><p><strong>doInBackground(Params… params)</strong><br>这个方法中的所有代码都会在子线程中执行，我们应该在这里去处理所有的耗时操作。任务完成时就可以通过return语句将执行结果返回，如果指定第三个参数为Void就不需要返回了。因为代码都是在子线程中执行的，所以注意不能再这里更新UI。如果需要反馈当前后台任务的执行进度，可以调用publishProgress(Progress… progress)方法来实现。</p></li><li><p><strong>OnProgressUpdate(Progress… progress)</strong><br>当后台任务调用publishProgress方法后，该方法很快就会被调用，其中的参数就是publishProgress传过来的。该方法里面可以对UI进行操作，利用参数中的数值就可以对界面元素进行相应的更新。</p></li><li><p><strong>onPostExecute(Result result)</strong><br>当后台任务执行完毕并通过return语句返回时，该方法很快就会被调用。返回的结果就会被作为参数传到该方法中。我们可以利用返回的数据来进行一些UI操作，比如提醒任务执行的结果，以及关闭对话框等。<br>所以，一个完整的AsyncTask可以如下所示：</p><pre class=" language-bash"><code class="language-bash">public class MyTask extends AsyncTask<span class="token operator">&lt;</span>Void,Integer,Boolean<span class="token operator">></span> <span class="token punctuation">{</span>  @Override  protected void onPreExecute<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      dialog.show<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//显示对话框  <span class="token punctuation">}</span>  @Override  protected Boolean doInBackground<span class="token punctuation">(</span>Void<span class="token punctuation">..</span>. voids<span class="token punctuation">)</span> <span class="token punctuation">{</span>      try<span class="token punctuation">{</span>          while<span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">{</span>              int downloadProgress <span class="token operator">=</span> downloadAndGetProgress<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//这是一个虚构的方法              publishProgress<span class="token punctuation">(</span>downloadProgress<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token keyword">if</span> <span class="token punctuation">(</span>downloadProgress <span class="token operator">>=</span> 100<span class="token punctuation">)</span><span class="token punctuation">{</span>                  <span class="token keyword">break</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>catch <span class="token punctuation">(</span>Exception e<span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>//下载失败      <span class="token punctuation">}</span>      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>//下载成功  <span class="token punctuation">}</span>  @Override  protected void onProgressUpdate<span class="token punctuation">(</span>Integer<span class="token punctuation">..</span>. values<span class="token punctuation">)</span> <span class="token punctuation">{</span>      //更新下载进度      dialog.setMessage<span class="token punctuation">(</span><span class="token string">"Download "</span> + values<span class="token punctuation">[</span>0<span class="token punctuation">]</span> + <span class="token string">"%"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  @Override  protected void onPostExecute<span class="token punctuation">(</span>Boolean result<span class="token punctuation">)</span> <span class="token punctuation">{</span>      dialog.dismiss<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//关闭对话框      <span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">{</span>          //提示下载成功      <span class="token punctuation">}</span>else<span class="token punctuation">{</span>          //提示下载失败      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>如果想要启动这个后台任务，只需要执行new MyTask().execute();即可。</p></li></ul><p>######2.2.3 注意</p><p>① 不要直接调用onPreExecute()、doInBackground()、onProgressUpdate()、onPostExecute()和onCancelled()方法。<br>② 一个异步对象只能调用过一次execute方法。</p><h5 id="2-3-HandlerThread"><a href="#2-3-HandlerThread" class="headerlink" title="2.3 HandlerThread"></a>2.3 HandlerThread</h5><h6 id="2-3-1-前言"><a href="#2-3-1-前言" class="headerlink" title="2.3.1 前言"></a>2.3.1 前言</h6><p>HandlerThread是一种具有消息循环的线程，其内部可使用Handler。通俗来讲，与子线程绑定的handler发送出去的消息，是在子线程当中执行的。</p><h6 id="2-3-2-使用方法"><a href="#2-3-2-使用方法" class="headerlink" title="2.3.2 使用方法"></a>2.3.2 使用方法</h6><p>整体思路：将子线程与workHandler绑定之后，在要进行耗时操作的地方通过workHandler发送消息，然后在通过mainHandler发送消息进行主线程的UI更新。</p><pre class=" language-bash"><code class="language-bash">        //第零步，创建主线程的handler，这里我称之为主handler        mainHandler <span class="token operator">=</span> new Handler<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            @Override            public void handleMessage<span class="token punctuation">(</span>Message msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>                switch <span class="token punctuation">(</span>msg.what<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">case</span> 1:                        btn_send.setText<span class="token punctuation">(</span><span class="token string">"after"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        //第一步，创建handlerThread对象        final HandlerThread handlerThread <span class="token operator">=</span> new HandlerThread<span class="token punctuation">(</span><span class="token string">"handlerThread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        //第二步，启动handlerTh        handlerThread.start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        //第三步，创建与handlerThread绑定的handler，这里我称之为工作handler        //其发送的消息都是在子线程中执行的        final Handler workHandler <span class="token operator">=</span> new Handler<span class="token punctuation">(</span>handlerThread.getLooper<span class="token punctuation">(</span><span class="token punctuation">)</span>, new Handler.Callback<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            @Override            public boolean handleMessage<span class="token punctuation">(</span>Message msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>                switch <span class="token punctuation">(</span>msg.what<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">case</span> 0:                        //这里做耗时操作                        Log.i<span class="token punctuation">(</span>TAG, <span class="token string">"我做了耗时操作。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        //做完耗时操作通过mainHandler进行UI的更新                        mainHandler.sendEmptyMessage<span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        //第四步，通过workHan发送消息来做耗时操作        btn_send <span class="token operator">=</span> findViewById<span class="token punctuation">(</span>R.id.btn_send<span class="token punctuation">)</span><span class="token punctuation">;</span>        btn_send.setOnClickListener<span class="token punctuation">(</span>new View.OnClickListener<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            @Override            public void onClick<span class="token punctuation">(</span>View v<span class="token punctuation">)</span> <span class="token punctuation">{</span>                new Thread<span class="token punctuation">(</span>new Runnable<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    @Override                    public void run<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        workHandler.sendEmptyMessage<span class="token punctuation">(</span>0<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span>.start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        //第五步，退出消息循环        btn_quit <span class="token operator">=</span> findViewById<span class="token punctuation">(</span>R.id.btn_quit<span class="token punctuation">)</span><span class="token punctuation">;</span>        btn_quit.setOnClickListener<span class="token punctuation">(</span>new View.OnClickListener<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            @Override            public void onClick<span class="token punctuation">(</span>View v<span class="token punctuation">)</span> <span class="token punctuation">{</span>                new Thread<span class="token punctuation">(</span>new Runnable<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    @Override                    public void run<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        handlerThread.quit<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span>.start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h6 id="2-3-3-注意"><a href="#2-3-3-注意" class="headerlink" title="2.3.3 注意"></a>2.3.3 注意</h6><p>① 如何将一个Thread线程变成一个Looper线程？<br>通过Looper.prepare()可将一个一个Thread线程变成一个Looper线程。</p><p>② Looper线程有什么特点？<br>它通过MessageQueue来存放消息，Looper.loop()进行消息轮询。</p><p>③ 可以在子线程直接new一个Handler吗？不行的话要怎么做？<br>因为子线程的Looper需要手动去创建，所以不可以直接new。<br>要new一个Handler的话可以这样做：</p><pre class=" language-bash"><code class="language-bash">new Thread<span class="token punctuation">(</span>new Runnable<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            @Override            public void run<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Looper.prepare<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//为子线程创建Looper                new Handler<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    @Override                    public void handleMessage<span class="token punctuation">(</span>Message msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        //这里的消息处理是在子线程中执行的                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">;</span>                Looper.loop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//开启消息轮询            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>.start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>在<strong>ActivityThread</strong>里调用了 <strong>Looper.prepareMainLooper()</strong>方法创建了主线程的 Looper ，并且调用了 loop() 方法，所以我们就可以直接在主线程使用 Handler 了</p></blockquote><h5 id="2-4-IntentService"><a href="#2-4-IntentService" class="headerlink" title="2.4 IntentService"></a>2.4 IntentService</h5><h6 id="2-4-1-前言"><a href="#2-4-1-前言" class="headerlink" title="2.4.1 前言"></a>2.4.1 前言</h6><p>不同于线程，它是服务，优先级比线程高，更不容易被系统杀死，因此较适合执行一些高优先级的后台任务；<br>不同于普通服务，它可自动创建子线程来执行后台任务，并且任务执行完毕后会自动退出。</p><h6 id="2-4-2-使用方法"><a href="#2-4-2-使用方法" class="headerlink" title="2.4.2 使用方法"></a>2.4.2 使用方法</h6><pre class=" language-bash"><code class="language-bash">//第一步，自定义服务public class MyIntentService extends IntentService <span class="token punctuation">{</span>    public MyIntentService<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        //必须调用父类的有参构造函数        super<span class="token punctuation">(</span><span class="token string">"ha"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//这里的ha是随便写的    <span class="token punctuation">}</span>    //重写onHandleIntent方法    @Override    protected void onHandleIntent<span class="token punctuation">(</span> Intent intent<span class="token punctuation">)</span> <span class="token punctuation">{</span>        //做耗时操作，因为该方法是在子线程中执行的    <span class="token punctuation">}</span>    @Override    public void onDestroy<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        super.onDestroy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Log.i<span class="token punctuation">(</span><span class="token string">"MyIntentService"</span>, <span class="token string">"MyIntentService onDestroy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>//第二步，注册服务<span class="token punctuation">(</span>在AndroidManifest文件中<span class="token punctuation">)</span><span class="token operator">&lt;</span>service android:name<span class="token operator">=</span><span class="token string">".MyIntentService"</span>/<span class="token operator">></span>//第三步，启动服务<span class="token punctuation">(</span>在activity中<span class="token punctuation">)</span>Intent intent <span class="token operator">=</span> new Intent<span class="token punctuation">(</span>MainActivity.this,MyIntentService.class<span class="token punctuation">)</span><span class="token punctuation">;</span>startService<span class="token punctuation">(</span>intent<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h6 id="2-4-3-注意"><a href="#2-4-3-注意" class="headerlink" title="2.4.3 注意"></a>2.4.3 注意</h6><p>① IntentService与Activity间通信：<br>Activity传值给IntentService：Intent、EventBus等<br>IntentService传值给Activity：广播、EventBus等（回调我试过了，竟然不行！）</p><p>② 为何不用bindService方式启动IntentService？<br>IntentService的工作原理是，在IntentService的onCreate里创建一个HandlerThread，并利用其内部的Looper实例化一个ServiceHandler对象；而这个ServiceHandler用于处理消息的handleMessage方法会去调用IntentService的onHandleIntent方法，这也是为什么可在该方法中去处理后台任务的原因。当有Intent任务请求时会把Intent封装成Message，然后ServiceHandler会把消息发送出去，而发送消息是在onStartCommand中完成的，只能通过startService方法才可走该生命周期方法，所以不能用bindService方式启动IntentService。</p><h3 id="三、服务的生命周期"><a href="#三、服务的生命周期" class="headerlink" title="三、服务的生命周期"></a>三、服务的生命周期</h3><p><img src="https://upload-images.jianshu.io/upload_images/15623160-5d615e1f533e4b2c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h5 id="3-1-通过startService方式启动服务"><a href="#3-1-通过startService方式启动服务" class="headerlink" title="3.1 通过startService方式启动服务"></a>3.1 通过startService方式启动服务</h5><ul><li>生命周期：onCreate -&gt; onStartCommand -&gt; onDestroy</li><li>通过stopService或者stopSelf方法停止服务。</li><li>一旦服务开启就跟调用者(开启者)没有任何关系了。</li><li>开启者退出了，开启者挂了，服务还在后台长期的运行。</li><li>开启者不能调用服务里面的方法。</li></ul><h5 id="3-2-通过bindService方式启动服务"><a href="#3-2-通过bindService方式启动服务" class="headerlink" title="3.2 通过bindService方式启动服务"></a>3.2 通过bindService方式启动服务</h5><ul><li>生命周期：onCreate -&gt; onBind -&gt; onUnBind -&gt; onDestroy</li><li>通过unbindService方法停止服务。</li><li>该方式开启服务，绑定服务，调用者挂了，服务也会跟着挂掉。</li><li>绑定者可以调用服务里面的方法。</li><li>常用于Service和Activity间通信。</li></ul><h5 id="3-3-注意"><a href="#3-3-注意" class="headerlink" title="3.3 注意"></a>3.3 注意</h5><p>① 当服务在启动之前还没有创建过，onCreate方法会先执行，否则不会再执行。<br>② 一个Activity先start一个Service之后，再bind时会回调什么方法？此时如何才能回调Service的destroy方法呢？<br>只会回调onBind方法。这种情况下要同时调用stopService和unbindService方法。</p><h3 id="四、服务的基本用法"><a href="#四、服务的基本用法" class="headerlink" title="四、服务的基本用法"></a>四、服务的基本用法</h3><h5 id="4-1-startService方式"><a href="#4-1-startService方式" class="headerlink" title="4.1 startService方式"></a>4.1 startService方式</h5><pre class=" language-bash"><code class="language-bash">//第一步，自定义类继承Service,必须重写onBind方法public class MyService extends Service <span class="token punctuation">{</span>    private static final String TAG <span class="token operator">=</span> <span class="token string">"MyService"</span><span class="token punctuation">;</span>    @Override    public IBinder onBind<span class="token punctuation">(</span>Intent intent<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Log.i<span class="token punctuation">(</span>TAG, <span class="token string">"onBind: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    //第二步，选择性的重写onCreate,onStartCommand和onDestroy方法    @Override    public void onCreate<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Log.i<span class="token punctuation">(</span>TAG, <span class="token string">"onCreate: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        super.onCreate<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    @Override    public int onStartCommand<span class="token punctuation">(</span>Intent intent, int flags, int startId<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Log.i<span class="token punctuation">(</span>TAG, <span class="token string">"onStartCommand: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> super.onStartCommand<span class="token punctuation">(</span>intent, flags, startId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    @Override    public void onDestroy<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Log.i<span class="token punctuation">(</span>TAG, <span class="token string">"onDestroy: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        super.onDestroy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>//第三步，注册服务<span class="token operator">&lt;</span>service android:name<span class="token operator">=</span><span class="token string">".MyService"</span>/<span class="token operator">></span>//第四步，启动或者停止服务//启动服务Intent intent <span class="token operator">=</span> new Intent<span class="token punctuation">(</span>Main3Activity.this,MyService.class<span class="token punctuation">)</span><span class="token punctuation">;</span>startService<span class="token punctuation">(</span>intent<span class="token punctuation">)</span><span class="token punctuation">;</span>//停止服务Intent intent <span class="token operator">=</span> new Intent<span class="token punctuation">(</span>Main3Activity.this,MyService.class<span class="token punctuation">)</span><span class="token punctuation">;</span>stopService<span class="token punctuation">(</span>intent<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="4-2-bindService方式-也是service与activity通信的方式"><a href="#4-2-bindService方式-也是service与activity通信的方式" class="headerlink" title="4.2 bindService方式(也是service与activity通信的方式)"></a>4.2 bindService方式(也是service与activity通信的方式)</h5><p>整体思路：<br>首先，自定义类继承Binder，按照自己的业务逻辑写相应的方法供activity调用。<br>然后，自定义类继承Service，在onBind方法中返回自定义的Binder。<br>接着，实例化ServiceConnection对象，重写onServiceConnected和onServiceDisconnected方法。<br>最后，bindService绑定服务即可。</p><pre class=" language-bash"><code class="language-bash">public class MyService extends Service <span class="token punctuation">{</span>    private static final String TAG <span class="token operator">=</span> <span class="token string">"MyService"</span><span class="token punctuation">;</span>    private DownloadBinder mBinder <span class="token operator">=</span> new DownloadBinder<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    //自定义类继承Binder    class DownloadBinder extends Binder <span class="token punctuation">{</span>        public void startDownload<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            Log.i<span class="token punctuation">(</span>TAG, <span class="token string">"startDownload: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        public int getProgress<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            Log.i<span class="token punctuation">(</span>TAG, <span class="token string">"getProgress: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> 0<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    @Override    public IBinder onBind<span class="token punctuation">(</span>Intent intent<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Log.i<span class="token punctuation">(</span>TAG, <span class="token string">"onBind: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> mBinder<span class="token punctuation">;</span> //返回自定义的Binder对象    <span class="token punctuation">}</span>    @Override    public void onCreate<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Log.i<span class="token punctuation">(</span>TAG, <span class="token string">"onCreate: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        super.onCreate<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    @Override    public boolean onUnbind<span class="token punctuation">(</span>Intent intent<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Log.i<span class="token punctuation">(</span>TAG, <span class="token string">"onUnbind: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> super.onUnbind<span class="token punctuation">(</span>intent<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    @Override    public void onDestroy<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Log.i<span class="token punctuation">(</span>TAG, <span class="token string">"onDestroy: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        super.onDestroy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-bash"><code class="language-bash">public class Main3Activity extends AppCompatActivity <span class="token punctuation">{</span>    private static final String TAG <span class="token operator">=</span> <span class="token string">"Main3Activity"</span><span class="token punctuation">;</span>    private Button btn_send,btn_quit<span class="token punctuation">;</span>    private MyService.DownloadBinder downloadBinder<span class="token punctuation">;</span>    private ServiceConnection connection <span class="token operator">=</span> new ServiceConnection<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        //service与activity绑定成功时调用        @Override        public void onServiceConnected<span class="token punctuation">(</span>ComponentName name, IBinder service<span class="token punctuation">)</span> <span class="token punctuation">{</span>            downloadBinder <span class="token operator">=</span> <span class="token punctuation">(</span>MyService.DownloadBinder<span class="token punctuation">)</span> <span class="token function">service</span><span class="token punctuation">;</span>            downloadBinder.startDownload<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            downloadBinder.getProgress<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        //service与activity绑定断开时调用        @Override        public void onServiceDisconnected<span class="token punctuation">(</span>ComponentName name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    @Override    protected void onCreate<span class="token punctuation">(</span>Bundle savedInstanceState<span class="token punctuation">)</span> <span class="token punctuation">{</span>        super.onCreate<span class="token punctuation">(</span>savedInstanceState<span class="token punctuation">)</span><span class="token punctuation">;</span>        setContentView<span class="token punctuation">(</span>R.layout.activity_main3<span class="token punctuation">)</span><span class="token punctuation">;</span>        btn_send <span class="token operator">=</span> findViewById<span class="token punctuation">(</span>R.id.btn_send<span class="token punctuation">)</span><span class="token punctuation">;</span>        btn_send.setOnClickListener<span class="token punctuation">(</span>new View.OnClickListener<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            @Override            public void onClick<span class="token punctuation">(</span>View v<span class="token punctuation">)</span> <span class="token punctuation">{</span>                Intent intent <span class="token operator">=</span> new Intent<span class="token punctuation">(</span>Main3Activity.this,MyService.class<span class="token punctuation">)</span><span class="token punctuation">;</span>                //第三个参数表示在活动和服务进行绑定后自动创建服务                bindService<span class="token punctuation">(</span>intent,connection,BIND_AUTO_CREATE<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        btn_quit <span class="token operator">=</span> findViewById<span class="token punctuation">(</span>R.id.btn_quit<span class="token punctuation">)</span><span class="token punctuation">;</span>        btn_quit.setOnClickListener<span class="token punctuation">(</span>new View.OnClickListener<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            @Override            public void onClick<span class="token punctuation">(</span>View v<span class="token punctuation">)</span> <span class="token punctuation">{</span>                //解除绑定                unbindService<span class="token punctuation">(</span>connection<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="五、前台服务"><a href="#五、前台服务" class="headerlink" title="五、前台服务"></a>五、前台服务</h3><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>服务几乎都是在后台运行的，系统优先级还是比较低的，当系统出现内存不足时就有可能会回收掉正在后台运行的服务。此时为了防止服务被回收掉，就可以使用前台服务。前台服务和普通服务最大的区别就在于，它会一直有一个正在运行的图标在系统状态栏显示，下拉状态栏可以看到更加详细的信息，非常类似于通知的效果。</p><h5 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h5><pre class=" language-bash"><code class="language-bash">public class MyService extends Service <span class="token punctuation">{</span>    <span class="token punctuation">..</span>.    @Override    public void onCreate<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        super.onCreate<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Intent intent <span class="token operator">=</span> new Intent<span class="token punctuation">(</span>this,MainActivity.class<span class="token punctuation">)</span><span class="token punctuation">;</span>        PendingIntent pi <span class="token operator">=</span> PendingIntent.getActivity<span class="token punctuation">(</span>this,0,intent,0<span class="token punctuation">)</span><span class="token punctuation">;</span>        Notification notification <span class="token operator">=</span> new Notification.Builder<span class="token punctuation">(</span>this<span class="token punctuation">)</span>                .setContentTitle<span class="token punctuation">(</span><span class="token string">"This is content title"</span><span class="token punctuation">)</span>                .setContentText<span class="token punctuation">(</span><span class="token string">"This is content text"</span><span class="token punctuation">)</span>                .setWhen<span class="token punctuation">(</span>System.currentTimeMillis<span class="token punctuation">(</span><span class="token punctuation">))</span>                .setSmallIcon<span class="token punctuation">(</span>R.mipmap.ic_launcher<span class="token punctuation">)</span>                .setLargeIcon<span class="token punctuation">(</span>BitmapFactory.decodeResource<span class="token punctuation">(</span>getResources<span class="token punctuation">(</span><span class="token punctuation">)</span>,R.mipmap.ic_launcher<span class="token punctuation">))</span>                .setContentIntent<span class="token punctuation">(</span>pi<span class="token punctuation">)</span>                .build<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        startForeground<span class="token punctuation">(</span>1,notification<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>现在Android对于通知栏已经做了修改，我们还需要去做版本适配，在这里我就不展开来讲了，贴一个郭神的文章吧<a href="https://blog.csdn.net/guolin_blog/article/details/79854070" target="_blank" rel="noopener">Android通知栏微技巧，8.0系统中通知栏的适配</a></p><h3 id="六、保证service不被杀死的方法"><a href="#六、保证service不被杀死的方法" class="headerlink" title="六、保证service不被杀死的方法"></a>六、保证service不被杀死的方法</h3><ul><li>在Service的onStartCommand方法中设置flages值为START_STICKY，使得Service被杀死后尝试再次启动Service。</li><li>提升Service优先级，比如设置为一个前台服务。</li><li>在Activity的onDestroy通过发送广播，并在广播接收器的onReceive中启动service。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Service </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Receiver</title>
      <link href="/2020/03/21/si-da-zu-jian-zhi-broadcastreceiver/"/>
      <url>/2020/03/21/si-da-zu-jian-zhi-broadcastreceiver/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文目录结构：<br>一、广播机制简介<br>二、接收系统广播<br>三、发送自定义广播<br>四、使用本地广播</p></blockquote><h3 id="一、广播机制简介"><a href="#一、广播机制简介" class="headerlink" title="一、广播机制简介"></a>一、广播机制简介</h3><h6 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h6><p>类似于网络通信原理中的广播，Android中也有一套类似的广播机制。通俗来讲，广播分为发送者和接收者，发送者发出一条广播，相应的接收者就会收到一条广播。简单来讲，广播就是Android中的一种通信方式。</p><h6 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h6><p>（1）同一app内部的同一组件内的消息通信（单个或多个线程之间）；<br>（2）同一app内部的不同组件之间的消息通信（单个进程）；<br>（3）同一app具有多个进程的不同组件之间的消息通信；<br>（4）不同app之间的组件之间消息通信；<br>（5）Android系统在特定情况下与App之间的消息通信。</p><h6 id="基本原理和实现流程"><a href="#基本原理和实现流程" class="headerlink" title="基本原理和实现流程"></a>基本原理和实现流程</h6><p>对于基本原理<br>广播使用了观察者模式，是基于消息的发布/订阅模型，与EventBus相似。广播发送者和广播接收者分别属于观察者模式中的消息发布和订阅两端，AMS属于中间的处理中心。广播发送者和广播接收者的执行是异步的，发出去的广播不会关心有无接收者接收，也不确定接收者到底是何时才能接收到。</p><p>对于实现流程，主要分为以下四步：<br>（1）首先，广播接收者BroadcastReceiver通过Binder机制向AMS(Activity Manager Service)进行注册；<br>（2）然后，广播发送者通过binder机制向AMS发送广播；<br>（3）接着，AMS查找符合相应条件（IntentFilter/Permission等）的BroadcastReceiver，将广播发送到BroadcastReceiver（一般情况下是Activity）相应的消息循环队列中；<br>（4）最后，消息循环执行拿到此广播，回调BroadcastReceiver中的onReceive()方法。</p><h6 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h6><p>Android中的广播主要分为两类：标准广播和有序广播</p><h6 id="标准广播"><a href="#标准广播" class="headerlink" title="标准广播"></a>标准广播</h6><p>标准广播是一种完全异步执行的广播，在广播发出之后，所有的广播接收器几乎都会在同一时刻接收到这条广播，所以他们之间没有任何顺序可言。这种广播的效率会比较高，但同时也意味着它是无法被截断的。<br><img src="https://upload-images.jianshu.io/upload_images/15623160-b91f76534a0eb44d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="标准广播工作示意图.png"></p><h6 id="有序广播"><a href="#有序广播" class="headerlink" title="有序广播"></a>有序广播</h6><p>有序广播是一种同步执行的广播，在广播发出之后，同一时刻只会有一个广播接收器能够接收到这条广播。当该接收器中的逻辑处理完毕后才会继续传递。所以此时的广播接收器是有先后顺序的，优先级高的广播接收器就可以先收到广播，并且前面的接收器还可以截断正在传递的广播，这样后面的接收器就收不到这条消息了。<br><img src="https://upload-images.jianshu.io/upload_images/15623160-27d6b0633b0a2ae0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="有序广播工作示意图.png"></p><h3 id="二、接收系统广播"><a href="#二、接收系统广播" class="headerlink" title="二、接收系统广播"></a>二、接收系统广播</h3><blockquote><p>Android内置了很多系统级别的广播，我们可以在应用程序中通过监听这些广播来得到系统的各种状态信息。比如手机开机完成后会发出一条广播，电池的电量发生变化会发出一条广播，时间或时区发生改变也会发出一条广播等等。<br><em>广播接收器的注册分为两类：动态在代码中注册和静态在AndroidManifest.xml文件中注册</em></p></blockquote><h6 id="动态注册监听网络变化"><a href="#动态注册监听网络变化" class="headerlink" title="动态注册监听网络变化"></a>动态注册监听网络变化</h6><p>整体思路：<br>首先，新建一个类让它继承BroadcastReceiver并重写父类onReceive方法。<br>然后，实例化IntentFilter对象并添加Action。<br>接着，在activity的生命周期函数中注册广播接收器。<br>最后，在activity的生命周期函数中取消注册广播接收器。</p><pre class=" language-bash"><code class="language-bash">public class NetworkChangeReceiver extends BroadcastReceiver <span class="token punctuation">{</span>    @Override    public void onReceive<span class="token punctuation">(</span>Context context, Intent intent<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ConnectivityManager connectivityManager <span class="token operator">=</span> <span class="token punctuation">(</span>ConnectivityManager<span class="token punctuation">)</span>context.getSystemService<span class="token punctuation">(</span>Context.CONNECTIVITY_SERVICE<span class="token punctuation">)</span><span class="token punctuation">;</span>        //这里需要申请权限        //<span class="token operator">&lt;</span>uses-permission android:name<span class="token operator">=</span><span class="token string">"android.permission.ACCESS_NETWORK_STATE"</span>/<span class="token operator">></span>        NetworkInfo networkInfo <span class="token operator">=</span> connectivityManager.getActiveNetworkInfo<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>networkInfo <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> networkInfo.isConnected<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">{</span>            Toast toast <span class="token operator">=</span> Toast.makeText<span class="token punctuation">(</span>context, <span class="token string">"网络恢复咯！"</span>, Toast.LENGTH_SHORT<span class="token punctuation">)</span><span class="token punctuation">;</span>            toast.setGravity<span class="token punctuation">(</span>Gravity.CENTER, 0, 0<span class="token punctuation">)</span><span class="token punctuation">;</span>            toast.show<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>else <span class="token punctuation">{</span>            Toast toast <span class="token operator">=</span> Toast.makeText<span class="token punctuation">(</span>context, <span class="token string">"网络开了点小差！"</span>, Toast.LENGTH_SHORT<span class="token punctuation">)</span><span class="token punctuation">;</span>            toast.setGravity<span class="token punctuation">(</span>Gravity.CENTER, 0, 0<span class="token punctuation">)</span><span class="token punctuation">;</span>            toast.show<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-bash"><code class="language-bash">public class MainActivity extends AppCompatActivity <span class="token punctuation">{</span>    private IntentFilter intentFilter<span class="token punctuation">;</span>    private NetworkChangeReceiver mNetworkChangeReceiver<span class="token punctuation">;</span>    @Override    protected void onCreate<span class="token punctuation">(</span>Bundle savedInstanceState<span class="token punctuation">)</span> <span class="token punctuation">{</span>        super.onCreate<span class="token punctuation">(</span>savedInstanceState<span class="token punctuation">)</span><span class="token punctuation">;</span>        setContentView<span class="token punctuation">(</span>R.layout.activity_main<span class="token punctuation">)</span><span class="token punctuation">;</span>        intentFilter <span class="token operator">=</span> new IntentFilter<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        //系统发出的广播就是android.net.conn.CONNECTIVITY_CHANGE        //所以我们的广播接收器想要监听什么样的广播，在这里添加相应的Action即可。        intentFilter.addAction<span class="token punctuation">(</span><span class="token string">"android.net.conn.CONNECTIVITY_CHANGE"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mNetworkChangeReceiver <span class="token operator">=</span> new NetworkChangeReceiver<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        registerReceiver<span class="token punctuation">(</span>mNetworkChangeReceiver,intentFilter<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    @Override    protected void onDestroy<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        super.onDestroy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        //动态注册的广播接收器一定都要取消注册才行        unregisterReceiver<span class="token punctuation">(</span>mNetworkChangeReceiver<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>动态注册可以自由地控制注册与注销，比较灵活，但这也意味着必须要启动该程序才会起作用。而静态注册可以解决该问题。</p></blockquote><h6 id="静态注册实现开机提醒"><a href="#静态注册实现开机提醒" class="headerlink" title="静态注册实现开机提醒"></a>静态注册实现开机提醒</h6><p>整体思路：<br>首先，同样是让一个类继承BrocastReceiver，并重写onReceive方法。<br>接着，在AndroidManifest文件中申请监听开机广播。<br>然后，在AndroidManifest文件中注册广播接收器即可。</p><pre class=" language-bash"><code class="language-bash">public class BootCompleteReceiver extends BroadcastReceiver <span class="token punctuation">{</span>    @Override    public void onReceive<span class="token punctuation">(</span>Context context, Intent intent<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Toast toast <span class="token operator">=</span> Toast.makeText<span class="token punctuation">(</span>context, <span class="token string">"开机啦！"</span>, Toast.LENGTH_SHORT<span class="token punctuation">)</span><span class="token punctuation">;</span>            toast.setGravity<span class="token punctuation">(</span>Gravity.CENTER, 0, 0<span class="token punctuation">)</span><span class="token punctuation">;</span>            toast.show<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>manifest <span class="token punctuation">..</span>.<span class="token operator">></span><span class="token operator">&lt;</span>uses-permission android:name<span class="token operator">=</span><span class="token string">"android.permission.RECEIVE_BOOT_COMPLETED"</span>/<span class="token operator">></span><span class="token punctuation">..</span>.<span class="token operator">&lt;</span><span class="token operator">!</span>--exported属性表示是否允许这个广播接收器接收本程序之外的广播--<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span>--enabled属性表示是否启用这个广播接收器--<span class="token operator">></span><span class="token operator">&lt;</span>application <span class="token punctuation">..</span>.<span class="token operator">></span>  <span class="token operator">&lt;</span>receiver    android:name<span class="token operator">=</span><span class="token string">".BootCompleteReceiver"</span>    android:enabled<span class="token operator">=</span><span class="token string">"true"</span>    android:exported<span class="token operator">=</span><span class="token string">"true"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>intent-filter<span class="token operator">></span>        <span class="token operator">&lt;</span>action android:name<span class="token operator">=</span><span class="token string">"android.intent.action.RECEIVE_BOOT_COMPLETED"</span>/<span class="token operator">></span>    <span class="token operator">&lt;</span>/intent-filter<span class="token operator">></span>  <span class="token operator">&lt;</span>/receiver<span class="token operator">></span><span class="token operator">&lt;</span>/application<span class="token operator">></span><span class="token operator">&lt;</span>/manifest<span class="token operator">></span></code></pre><blockquote><p>注意，不要在onReceive方法中添加过多的逻辑或者进行任何的耗时操作，因为在广播接收器中是不允许开线程的。当onReceive方法运行了较长时间（最长10s）而没有结束时，程序就会报错。</p></blockquote><h3 id="三、发送自定义广播"><a href="#三、发送自定义广播" class="headerlink" title="三、发送自定义广播"></a>三、发送自定义广播</h3><p><strong>发送标准广播</strong><br>整体思路：<br>首先，构建一个Intent对象。<br>然后，把要发送的广播的值传进去。<br>最后，调用Context的sendBroadcast方法发送出去即可。</p><pre class=" language-bash"><code class="language-bash">//这里发出了一条为top.longsh1z.www.broadcasttest.MY_BROADCAST的广播Intent intent <span class="token operator">=</span> new Intent<span class="token punctuation">(</span><span class="token string">"top.longsh1z.www.broadcasttest.MY_BROADCAST"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sendBroadcast<span class="token punctuation">(</span>intent<span class="token punctuation">)</span><span class="token punctuation">;</span>//因为广播是使用Intent进行传递的，所以还可以在Intent中携带一些数据传递给广播接收器//onReceive方法中的第二个参数为Intent对象，取出来使用即可。</code></pre><p><strong>发送有序广播</strong><br>整体思路：<br>和发送自定义广播类似，都是构建Intent对象，设置广播的值，最后发送出去即可。但这里的发送从sendBroadcast变成了sendOrderedBroadcast，然后给广播接收器设置优先级，在onReceive方法设置是否截断广播。</p><pre class=" language-bash"><code class="language-bash">Intent intent <span class="token operator">=</span> new Intent<span class="token punctuation">(</span><span class="token string">"top.longsh1z.www.broadcasttest.MY_BROADCAST"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sendOrderedBroadcast<span class="token punctuation">(</span>intent,null<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-bash"><code class="language-bash">//若为动态注册的广播接收器，设置优先级为如下步骤：intentFilter <span class="token operator">=</span> new IntentFilter<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>intentFilter.addAction<span class="token punctuation">(</span><span class="token string">"top.longsh1z.www.broadcasttest.MY_BROADCAST"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>intentFilter.setPriority<span class="token punctuation">(</span>100<span class="token punctuation">)</span><span class="token punctuation">;</span>         //设置优先级myReceiver <span class="token operator">=</span> new MyReceiver<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>registerReceiver<span class="token punctuation">(</span>myReceiver,intentFilter<span class="token punctuation">)</span><span class="token punctuation">;</span>//若为静态注册的广播接收器，则在Manifest文件中设置：<span class="token operator">&lt;</span>receiver    android:name<span class="token operator">=</span><span class="token string">".MyReceiver"</span>    android:enabled<span class="token operator">=</span><span class="token string">"true"</span>    android:exported<span class="token operator">=</span><span class="token string">"true"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>intent-filter android:priority<span class="token operator">=</span><span class="token string">"100"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>action android:name<span class="token operator">=</span><span class="token string">"top.longsh1z.www.broadcasttest.MY_BROADCAST"</span>/<span class="token operator">></span>    <span class="token operator">&lt;</span>/intent-filter<span class="token operator">></span>  <span class="token operator">&lt;</span>/receiver<span class="token operator">></span></code></pre><pre class=" language-bash"><code class="language-bash">public class MyReceiver extends BroadcastReceiver <span class="token punctuation">{</span>    @Override    public void onReceive<span class="token punctuation">(</span>Context context, Intent intent<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Toast toast <span class="token operator">=</span> Toast.makeText<span class="token punctuation">(</span>context, <span class="token string">"发送有序广播啦！"</span>, Toast.LENGTH_SHORT<span class="token punctuation">)</span><span class="token punctuation">;</span>            toast.setGravity<span class="token punctuation">(</span>Gravity.CENTER, 0, 0<span class="token punctuation">)</span><span class="token punctuation">;</span>            toast.show<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            //截断广播，后面的广播接收器就收不到该条广播了。            abortBroadcast<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="四、使用本地广播"><a href="#四、使用本地广播" class="headerlink" title="四、使用本地广播"></a>四、使用本地广播</h3><blockquote><p>前面我们发送和接收的广播全部属于系统全局广播，即发出的广播可以被其他任何应用程序接收到，并且我们也可以接收到来自其他任何应用程序的广播。所以就存在着安全性的问题。而使用本地广播可以只在本应用程序内起作用，不涉及安全问题。</p></blockquote><p>整体思路：<br>和动态注册广播接收器差不多，只不过是加多了一个LocalBroadcastManager类对象来注册和注销广播接收器而已。</p><pre class=" language-bash"><code class="language-bash">public class MainActivity extends AppCompatActivity <span class="token punctuation">{</span>    private IntentFilter intentFilter<span class="token punctuation">;</span>    private LocalReceiver localReceiver<span class="token punctuation">;</span>    private LocalBroadcastManager localBroadcastManager<span class="token punctuation">;</span>    @Override    protected void onCreate<span class="token punctuation">(</span>Bundle savedInstanceState<span class="token punctuation">)</span> <span class="token punctuation">{</span>        super.onCreate<span class="token punctuation">(</span>savedInstanceState<span class="token punctuation">)</span><span class="token punctuation">;</span>        setContentView<span class="token punctuation">(</span>R.layout.activity_main<span class="token punctuation">)</span><span class="token punctuation">;</span>        localBroadcastManager <span class="token operator">=</span> LocalBroadcastManager.getInstance<span class="token punctuation">(</span>this<span class="token punctuation">)</span><span class="token punctuation">;</span>        Button button <span class="token operator">=</span> findViewById<span class="token punctuation">(</span>R.id.button<span class="token punctuation">)</span><span class="token punctuation">;</span>        button.setOnClickListener<span class="token punctuation">(</span>new View.OnClickListener<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          @Override          protected void onClick<span class="token punctuation">(</span>View v<span class="token punctuation">)</span><span class="token punctuation">{</span>            Intent intent <span class="token operator">=</span> new Intent<span class="token punctuation">(</span><span class="token string">"top.longsh1z.www.broadcasttset.LOCAL_BROADCAST"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            localBroadcastManager.sendBroadcast<span class="token punctuation">(</span>intent<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        intentFilter <span class="token operator">=</span> new IntentFilter<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        intentFilter.addAction<span class="token punctuation">(</span><span class="token string">"top.longsh1z.www.broadcasttset.LOCAL_BROADCAST"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        localReceiver<span class="token operator">=</span> new LocalReceiver<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        localBroadcastManager.registerReceiver<span class="token punctuation">(</span>localReceiver,intentFilter<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    @Override    protected void onDestroy<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        super.onDestroy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        //动态注册的广播接收器一定都要取消注册才行        localBroadcastManager.unregisterReceiver<span class="token punctuation">(</span>mNetworkChangeReceiver<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     class LocalReceiver extends BroadcastReceiver<span class="token punctuation">{</span>     @Override     public void onReceive<span class="token punctuation">(</span>Context context, Intent intent<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Toast toast <span class="token operator">=</span> Toast.makeText<span class="token punctuation">(</span>context, <span class="token string">"收到本地广播啦！"</span>, Toast.LENGTH_SHORT<span class="token punctuation">)</span><span class="token punctuation">;</span>            toast.setGravity<span class="token punctuation">(</span>Gravity.CENTER, 0, 0<span class="token punctuation">)</span><span class="token punctuation">;</span>            toast.show<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>本地广播是无法通过静态注册的方式来接收的，因为静态注册主要是为了让程序在未启动的情况下也能接收到广播，而发送本地广播时程序已经启动了。所以就没必要静态注册了。</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Broadcast Receiver </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四大组件之Activity</title>
      <link href="/2020/03/21/si-da-zu-jian-zhi-activity/"/>
      <url>/2020/03/21/si-da-zu-jian-zhi-activity/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文目录结构：<br>一、活动的生命周期<br>二、活动的启动模式<br>三、活动间的信息传递之一 —— Intent</p></blockquote><h3 id="一、活动的生命周期"><a href="#一、活动的生命周期" class="headerlink" title="一、活动的生命周期"></a>一、活动的生命周期</h3><h6 id="1-返回栈"><a href="#1-返回栈" class="headerlink" title="1.返回栈"></a>1.返回栈</h6><p>Android是使用任务（Task）来管理活动的，一个任务就是一组存放在栈里的活动的集合，这个栈也叫返回栈。在默认情况下，当我们启动了一个活动，那么它会入栈，并处于栈顶的位置。当我们按下返回键或者调用finish方法时，处于栈顶的活动就会出栈。系统总是显示处于栈顶的活动。</p><h6 id="2-活动状态"><a href="#2-活动状态" class="headerlink" title="2.活动状态"></a>2.活动状态</h6><p>活动的状态可以分为4种：<br><strong>（1）运行状态</strong><br>当一个活动处于栈顶的时候，那么它就处于运行状态。系统就不愿意就是回收运行状态的活动，因为这会给用户带来很不好的体验。<br><strong>（2）暂停状态</strong><br>当一个活动不处于栈顶但仍然可见时，它就处于暂停状态。比如对话框形式的活动只会占用屏幕中间的区域。系统也不愿意回收这样的活动，只有在内存极低的时候才会考虑去回收。<br><strong>（3）停止状态</strong><br>当一个活动不再处于栈顶，并且不可见的时候，就进入了停止状态。系统仍然会为这种活动保存相应的状态和成员变量，但这并不是完全可靠的。当其他地方需要内存，系统就有可能回收掉该活动。<br><strong>（4）销毁状态</strong><br>当一个活动被栈移除之后，它就处于销毁状态。系统最愿意回收这样的活动，从而保持手机内存的充足。</p><h6 id="3-活动的生命周期"><a href="#3-活动的生命周期" class="headerlink" title="3.活动的生命周期"></a>3.活动的生命周期</h6><p><strong>（1）onCreate</strong><br>它会在活动第一次创建的时候被调用。我们应该在该方法中完成活动的初始化操作，比如加载布局、绑定事件等。<br><strong>（2）onStart</strong><br>该方法在活动由不可见变为可见的时候调用。<br><strong>（3）onResume</strong><br>该方法在活动准备好和用户交互的时候调用。此时的活动一定处于栈顶的位置。<br><strong>（4）onPause</strong><br>该方法在系统准备去启动或恢复另一个活动的时候调用。我们通常会在这个方法中将一些消耗CPU的资源释放掉，但该方法的执行速度一定要快，不然会影响到新的栈顶活动的调用。<br><strong>（5）onStop</strong><br>该方法在活动完全不可见的时候调用。它和onPause方法不同的是，如果启动的新活动是一个对话框形式的活动，那么onPause方法会被调用，而它不会。<br><strong>（6）onDestroy</strong><br>该方法会在活动被销毁之前调用。<br><strong>（7）onRestart</strong><br>该方法会在活动从停止状态变为运行状态之前调用。<br><img src="https://upload-images.jianshu.io/upload_images/15623160-740bf5ba73e9c647.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="活动的生命周期.jpg"></p><blockquote><p>PS:如果活动被销毁了，但是可能存在临时数据和状态，那要怎么办呢？<br>①可以调用onSaveInstanceState方法将数据临时保存起来<br>@Override<br>protected void onSaveInstanceState(Bundle outState){<br>  super.onSaveInstanceState(outState);<br>  String data = “Keep it”;<br>  outState.putString(“tempData”,data);<br>}<br>②然后在onCreate方法中判断savedInstanceState是否为空<br>@Override<br>protected void onCreate(Bundle savedInstanceState){<br>  super.onCreate(savedInstanceState);<br>  ……<br>  if(savedInstanceState != null)<br>  String tempData = savedInstanceState.getString(“tempData”);<br>}</p></blockquote><h3 id="二、活动的启动模式"><a href="#二、活动的启动模式" class="headerlink" title="二、活动的启动模式"></a>二、活动的启动模式</h3><p>活动的启动模式一共有4种，它们需要在AndroidManifest文件中通过给<activity>标签指定android:launchMode属性来设置。</activity></p><h6 id="1-standard"><a href="#1-standard" class="headerlink" title="1.standard"></a>1.standard</h6><p>它是活动默认的启动模式。每当有一个活动启动时，它就会入栈并处于栈顶的位置。系统根本不在乎栈里是否已经有了该活动的实例，每次启动活动都会创建一个新的实例。<br><img src="https://upload-images.jianshu.io/upload_images/15623160-595907773053c65e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="standard.jpg"></p><h6 id="2-singleTop"><a href="#2-singleTop" class="headerlink" title="2.singleTop"></a>2.singleTop</h6><p>当活动指定为该模式时，在启动活动时如果发现栈顶的活动已经是该活动，则系统会直接使用它，不会再创建新的活动实例。但如果该活动不在栈顶时再启动该活动时，还是会创建新的实例的。<br><img src="https://upload-images.jianshu.io/upload_images/15623160-85badf440c8b0535.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="singleTop.jpg"></p><h6 id="3-singleTask"><a href="#3-singleTask" class="headerlink" title="3.singleTask"></a>3.singleTask</h6><p>当活动处于该模式时，每次启动活动时系统首先会在栈里检查是否存在该活动的实例，如果发现有则直接使用，并把在该活动之上的所有活动出栈。如果没发现则创建一个新的活动实例。<br><img src="https://upload-images.jianshu.io/upload_images/15623160-6334be4faed21de6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="singleTask.jpg"></p><h6 id="4-singleInstance"><a href="#4-singleInstance" class="headerlink" title="4.singleInstance"></a>4.singleInstance</h6><p>当活动处于该模式时，系统会启用一个新的栈来管理这个活动。它可以解决共享活动实例的问题。比如：活动B为该模式，然后A启动B，B启动C，那么第一次按下返回键时系统会回到A，再按下一次时会回到B，再按下一次则退出应用。一个栈里的活动没有了之后才会去到另一个栈。<br><img src="https://upload-images.jianshu.io/upload_images/15623160-e4ece33e363cfc1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="singleInstance.png"></p><h3 id="三、活动间的信息传递之一-——-Intent"><a href="#三、活动间的信息传递之一-——-Intent" class="headerlink" title="三、活动间的信息传递之一 —— Intent"></a>三、活动间的信息传递之一 —— Intent</h3><h6 id="1-显式Intent"><a href="#1-显式Intent" class="headerlink" title="1.显式Intent"></a>1.显式Intent</h6><p>（1）构造方法</p><pre class=" language-bash"><code class="language-bash">//Intent intent <span class="token operator">=</span> new Intent<span class="token punctuation">(</span>Context packageContext,Class<span class="token operator">&lt;</span>?<span class="token operator">></span> cls<span class="token punctuation">)</span><span class="token punctuation">;</span>//前者为启动活动的上下文，后者为想要启动的目标活动Intent intent <span class="token operator">=</span> new Intent<span class="token punctuation">(</span>FirstActivity.this,SecondActivity.class<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>（2）setComponent方法</p><pre class=" language-bash"><code class="language-bash">ComponentName componentName <span class="token operator">=</span> new ComponentName<span class="token punctuation">(</span>this, SecondActivity.class<span class="token punctuation">)</span><span class="token punctuation">;</span>  Intent intent <span class="token operator">=</span> new Intent<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  intent.setComponent<span class="token punctuation">(</span>componentName<span class="token punctuation">)</span><span class="token punctuation">;</span>  startActivity<span class="token punctuation">(</span>intent<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>（3）setClass/setClassName方法</p><pre class=" language-bash"><code class="language-bash">Intent intent <span class="token operator">=</span> new Intent<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  intent.setClass<span class="token punctuation">(</span>this, SecondActivity.class<span class="token punctuation">)</span><span class="token punctuation">;</span>  // 或者intent.setClassName<span class="token punctuation">(</span>this, <span class="token string">"top.longsh1z.www.SecondActivity"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  // 或者intent.setClassName<span class="token punctuation">(</span>this.getPackageName<span class="token punctuation">(</span><span class="token punctuation">)</span>, <span class="token string">"top.longsh1z.www.SecondActivity"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        startActivity<span class="token punctuation">(</span>intent<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h6 id="2-隐式Intent"><a href="#2-隐式Intent" class="headerlink" title="2.隐式Intent"></a>2.隐式Intent</h6><p>顾名思义，隐式Intent不会明确的指出想要启动的activity，而是通过指定action和category等信息让系统来选择要启动的活动。</p><p>首先，在AndroidManifest文件中，目标活动要有<intent-filter>标签，里面包含<action><category>子标签，只有这两个子标签中的内容同时匹配才能够生效。比如：</category></action></intent-filter></p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>activity android:name<span class="token operator">=</span><span class="token string">".ui.Main2Activity"</span><span class="token operator">></span>  <span class="token operator">&lt;</span>intent-filter<span class="token operator">></span>    <span class="token operator">&lt;</span>action android:name<span class="token operator">=</span><span class="token string">"top.longsh1z.www.Main2Activity"</span>/<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span>--该category是一种默认的category--<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span>--在调用startActivity方法时会自动将这个category加到intent中--<span class="token operator">></span>    <span class="token operator">&lt;</span>category android:name<span class="token operator">=</span><span class="token string">"android.intent.category.DEFAULT"</span>/<span class="token operator">></span>  <span class="token operator">&lt;</span>/intent-filter<span class="token operator">></span><span class="token operator">&lt;</span>/activity<span class="token operator">></span></code></pre><p>设置intent有两种方法：<br>（1）构造方法</p><pre class=" language-bash"><code class="language-bash">Intent intent <span class="token operator">=</span> new Intent<span class="token punctuation">(</span><span class="token string">"top.longsh1z.www.Main2Activity"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//如果category不是默认的话要再加下面的一条语句//比如在AndroidManifest中自定义的category为//top.longsh1z.www.Main2Activity_category，那么该语句为//intent.addCategory<span class="token punctuation">(</span><span class="token string">"top.longsh1z.www.Main2Activity_category"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>startActivity<span class="token punctuation">(</span>intent<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>（2）setAction方法</p><pre class=" language-bash"><code class="language-bash">Intent intent <span class="token operator">=</span> new Intent<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>intent.setAction<span class="token punctuation">(</span><span class="token string">"top.longsh1z.www.Main2Activity"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//如果category不是默认的话同上startActivity<span class="token punctuation">(</span>intent<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h6 id="3-更多隐式Intent的用法"><a href="#3-更多隐式Intent的用法" class="headerlink" title="3.更多隐式Intent的用法"></a>3.更多隐式Intent的用法</h6><p>我们也可以调用系统中固有的活动，比如系统的浏览器，拨号等等。比如调用系统浏览器：</p><pre class=" language-bash"><code class="language-bash">//Intent.ACTION_VIEW是系统内置的动作，其常量值为android.intent.action.VIEWIntent intent <span class="token operator">=</span> new Intent<span class="token punctuation">(</span>Intent.ACTION_VIEW<span class="token punctuation">)</span><span class="token punctuation">;</span>//这条语句的意思是打开百度，具体其他用法请自己搜索intent.setData<span class="token punctuation">(</span>Uri.parse<span class="token punctuation">(</span><span class="token string">"https://www.baidu.com"</span><span class="token punctuation">))</span><span class="token punctuation">;</span>startActivity<span class="token punctuation">(</span>intent<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>另外，在一个活动的<action>标签里也可以写成系统内置的动作。当然这个前提是你的程序要有这样的功能，不然的话就会报错。</action></strong></p><h6 id="4-向下一个活动传递数据"><a href="#4-向下一个活动传递数据" class="headerlink" title="4.向下一个活动传递数据"></a>4.向下一个活动传递数据</h6><p>使用intent.putExtra方法放消息，使用intent.getStringExtra方法拿消息。</p><pre class=" language-bash"><code class="language-bash">//放消息进intent中String data <span class="token operator">=</span> <span class="token string">"Hello world!"</span><span class="token punctuation">;</span>Intent intent <span class="token operator">=</span> new Intent<span class="token punctuation">(</span>FirstActivity.this,SecondActivity.class<span class="token punctuation">)</span><span class="token punctuation">;</span>intent.putExtra<span class="token punctuation">(</span><span class="token string">"MyData"</span>,data<span class="token punctuation">)</span><span class="token punctuation">;</span>//其中data不一定只限于字符串，也可以为int,boolean类型startActivity<span class="token punctuation">(</span>intent<span class="token punctuation">)</span><span class="token punctuation">;</span>//取消息Intent intent <span class="token operator">=</span> getIntent<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String data <span class="token operator">=</span> intent.getStringExtra<span class="token punctuation">(</span><span class="token string">"MyData"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//若传递的数据为其他类型，则为getXxxExtra方法，比如getIntExtra,getBooleanExtra方法</code></pre><p><strong>5.返回数据给上一个活动</strong><br>总体思路为（这里假设是FActivity&lt;简写为F&gt;）跳到SActivity&lt;简写为S&gt;，再S返回数据给F）<br>先在F中使用startActivityForResult方法向S传递一个唯一的请求码，<br>然后在S中使用setResult方法将结果码和数据返回给F，<br>最后F在onActivityResult中通过请求码和结果码拿到返回的数据。</p><pre class=" language-bash"><code class="language-bash">//F中：Intent intent <span class="token operator">=</span> new Intent<span class="token punctuation">(</span>F.this,S.class<span class="token punctuation">)</span><span class="token punctuation">;</span>startActivityForResult<span class="token punctuation">(</span>intent,1<span class="token punctuation">)</span><span class="token punctuation">;</span>//这里请求码为1//S中：Intent intent <span class="token operator">=</span> new Intent<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>intent.putExtra<span class="token punctuation">(</span><span class="token string">"dataReturn"</span>,<span class="token string">"I am dataReturn."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>setResult<span class="token punctuation">(</span>RESULT_OK,intent<span class="token punctuation">)</span><span class="token punctuation">;</span>//第一个参数一般只使用RESULT_OK或RESULT_CANCELED这两个值//F中：@Overrideprotected void onActivityResult<span class="token punctuation">(</span>int requestCode,int resultCode,Intent data<span class="token punctuation">)</span><span class="token punctuation">{</span>  //第一个参数为请求码，是为了区分是哪个activity返回的数据，即数据来源  //第二个参数是判断处理结果是否成功  //第三个参数就是返回的数据  switch<span class="token punctuation">(</span>requestCode<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">case</span> 1:      if<span class="token punctuation">(</span>resultCode <span class="token operator">==</span> RESULT_OK<span class="token punctuation">)</span><span class="token punctuation">{</span>        String data <span class="token operator">=</span> intent.getStringExtra<span class="token punctuation">(</span><span class="token string">"dataReturn"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Activity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android学习（一）—— 基本概况</title>
      <link href="/2020/03/21/ji-ben-gai-kuang/"/>
      <url>/2020/03/21/ji-ben-gai-kuang/</url>
      
        <content type="html"><![CDATA[<blockquote><p>该Android学习系列主要是参考郭神的第一行代码（第二版）来学习的，目的是在学习的过程中记录下一些重要的知识点，不喜勿喷，谢谢。</p></blockquote><h2 id="一、Android系统架构"><a href="#一、Android系统架构" class="headerlink" title="一、Android系统架构"></a>一、Android系统架构</h2><h3 id="1-架构图"><a href="#1-架构图" class="headerlink" title="1.架构图"></a>1.架构图</h3><p><img src="http://longsh1z.top/resources/HexoBlog/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%86%B5/%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg" alt="架构图"></p><h3 id="2-层级说明"><a href="#2-层级说明" class="headerlink" title="2.层级说明"></a>2.层级说明</h3><h4 id="（1）Linux内核层"><a href="#（1）Linux内核层" class="headerlink" title="（1）Linux内核层"></a>（1）Linux内核层</h4><p> Android系统是基于Linux内核的，这一层为Android设备的各种硬件提供了底层的驱动，如显示驱动，音频驱动等。</p><h4 id="（2）系统运行库层"><a href="#（2）系统运行库层" class="headerlink" title="（2）系统运行库层"></a>（2）系统运行库层</h4><p> 这一层通过一些C/C++库来为Android系统提供了主要的特性支持。如OpenGL|ES库提供了3D绘图的支持。同时，这一层还有Android运行时库，它主要提供了一些核心库，能够允许开发者使用Java来编写Android应用。另外，它还包含了Dalvik虚拟机，能够使得每一个Android应用都能运行在独立的进程当中，并且拥有一个自己的Dalvik虚拟机实例。相比于Java虚拟机，它是专门为移动设备定制的，针对手机内存，CPU性能有限等情况做了优化处理。</p><h4 id="（3）应用框架层"><a href="#（3）应用框架层" class="headerlink" title="（3）应用框架层"></a>（3）应用框架层</h4><p>这一层主要提供了构建应用程序时可能用到的各种API。</p><h4 id="（4）应用层"><a href="#（4）应用层" class="headerlink" title="（4）应用层"></a>（4）应用层</h4><p>所有安装在手机上的应用程序都属于这一层。</p><blockquote><p>现在好像多了一层，硬件抽象层。是由于制作手机的工厂不愿意分享源码导致！如下图所示：</p></blockquote><p><img src="http://longsh1z.top/resources/HexoBlog/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%86%B5/%E6%96%B0%E7%89%88%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="新版架构图"></p><h3 id="3-Android应用开发特色"><a href="#3-Android应用开发特色" class="headerlink" title="3.Android应用开发特色"></a>3.Android应用开发特色</h3><p>（1）四大组件</p><p>Activity（活动）：是所有Android应用程序的门面，凡是在应用中看到的东西都是放在activity中的。</p><p>Service（服务）：前台看不到，是在后台默默运行的，即使退出应用service仍然可以继续运行。</p><p>Broadcast Receiver（广播接收器）：它允许你的应用接收或者发出广播消息。</p><p>Content Provider（内容提供器）：它为应用程序之间共享数据提供了可能。</p><p>（2）丰富的系统控件</p><p>（3）SQLite数据库</p><p>（4）强大的多媒体</p><p>（5）地理位置定位</p><h3 id="4-程序的项目结构（项目结构模式为project）"><a href="#4-程序的项目结构（项目结构模式为project）" class="headerlink" title="4.程序的项目结构（项目结构模式为project）"></a>4.程序的项目结构（项目结构模式为project）</h3><p>（1）总览图</p><p><img src="http://longsh1z.top/resources/HexoBlog/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%86%B5/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E6%80%BB%E8%A7%88%E5%9B%BE.png" alt=""></p><p>（2）.gradle和.idea</p><p>这两个目录下放置的是Android Studio（以下简称为AS）自动生成的一些文件。</p><p>（3）app</p><p>项目中的代码、资源等内容几乎都是放置在该目录下。</p><p>（4）build</p><p>它主要包含了一些在编译时自动生成的文件。</p><p>（5）gradle</p><p>这个目录下包含了gradle wrapper的配置文件，使用gradle wrapper的方式不需要提前将gradle下载好，而是会自动根据本地的缓存情况决定是否需要联网下载gradle。AS默认没有开启。</p><p>（6）.gitignore</p><p>该文件是用来将指定的目录或文件排除在版本控制之外。</p><p>（7）build.gradle</p><p>这是项目全局的gradle构建脚本。</p><p>（8）gradle.properties</p><p>该文件是全局的gradle配置文件，在这里配置的属性将会影响到项目中所有的gradle编译脚本。</p><p>（9）gradlew和gradlew.bat</p><p>这两个文件是用来在命令行中执行gradle命令的，前者是在Linux或Mac系统中使用，后者是在Windows系统中使用。</p><p>（10）local.properties</p><p>该文件用来指定本电脑中Android SDK的路径。</p><p>（11）MyCat.iml</p><p>iml文件是所有IntelliJ IDEA项目都会自动生成的一个文件（AS也是其旗下的一款软件），用来标识这是一个IntelliJ IDEA项目。</p><p>（12）settings.gradle</p><p>该文件用于指定该项目中引入的模块。 </p><p><img src="http://longsh1z.top/resources/HexoBlog/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%86%B5/settings_gradle.png" alt=""></p><h3 id="5-app目录下的主要内容具体分析"><a href="#5-app目录下的主要内容具体分析" class="headerlink" title="5.app目录下的主要内容具体分析"></a>5.app目录下的主要内容具体分析</h3><p>（1）总览图</p><p><img src="http://longsh1z.top/resources/HexoBlog/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%86%B5/app%E7%9B%AE%E5%BD%95%E6%80%BB%E8%A7%88%E5%9B%BE.png" alt=""></p><p>（2）libs</p><p>该目录主要放置一些第三方的jar包。</p><p>（3）androidTest</p><p>此处是用来编写Android Test测试用例的，可以对项目进行一些自动化测试。</p><p>（4）java</p><p>该目录是放置所有Java代码的地方。</p><p>（5）res</p><p>该目录主要放置项目中用到的所有图片、布局、字符串等资源。其中，drawable目录放置图片，layout目录放置布局，values目录放置字符串。</p><p>（6）AndroidManifest.xml</p><p>它是整个Android项目的配置文件。</p><p>（7）build.gradle</p><p>这是app模块的gradle构建脚本。</p><h3 id="6-全局build-gradle文件讲解"><a href="#6-全局build-gradle文件讲解" class="headerlink" title="6.全局build.gradle文件讲解"></a>6.全局build.gradle文件讲解</h3><p>（1）文件内容</p><p><img src="http://longsh1z.top/resources/HexoBlog/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%86%B5/%E5%85%A8%E5%B1%80build_gradle%E6%96%87%E4%BB%B6.png" alt=""></p><p>（2）jcenter</p><p>其实它是一个代码托管仓库，很多Android开源项目都会选择将代码托管到 jecnter 中，声明了这行配置之后，我们就可以在项目中引用任何jcenter上的开源项目了。</p><p>（3）classpath</p><p>dependency闭包中使用了classpath声明了一个Gradle插件。因为它不是专门为构建Android项目开发的，Java、C++等都可以使用Gradle来构建，所以我们要想使用它来构建Android项目就需要声明这个插件。</p><h3 id="7-app目录下build-gradle文件讲解"><a href="#7-app目录下build-gradle文件讲解" class="headerlink" title="7.app目录下build.gradle文件讲解"></a>7.app目录下build.gradle文件讲解</h3><p><img src="http://longsh1z.top/resources/HexoBlog/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%86%B5/app%E7%9B%AE%E5%BD%95build_gradle_1.png" alt=""></p><p><img src="http://longsh1z.top/resources/HexoBlog/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%86%B5/app%E7%9B%AE%E5%BD%95build_gradle_2.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Android入门 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
